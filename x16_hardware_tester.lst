Sections:
00: "segc000" (C000-D149)
01: "segf700" (F700-FF07)
02: "segfffa" (FFFA-C000)


Source: "x16_hardware_tester.s"
                        	     1: 
                        	     2: ; ===========================
                        	     3: ; === X16 Hardware Tester ===
                        	     4: ; ===========================
                        	     5: 
                        	     6: 
                        	     7: ; == Zero page addresses
                        	     8: 
                        	     9: ; Bank switching
                        	    10: RAM_BANK            = $00
                        	    11: ROM_BANK            = $01
                        	    12: 
                        	    13: ; Temp vars
                        	    14: TMP1                = $02
                        	    15: TMP2                = $03
                        	    16: TMP3                = $04
                        	    17: TMP4                = $05
                        	    18: 
                        	    19: ; Printing
                        	    20: TEXT_TO_PRINT       = $06 ; 07
                        	    21: TEXT_COLOR          = $08
                        	    22: CURSOR_X            = $09
                        	    23: CURSOR_Y            = $0A
                        	    24: INDENTATION         = $0B
                        	    25: BYTE_TO_PRINT       = $0C
                        	    26: DECIMAL_STRING      = $0D ; 0E ; 0F
                        	    27: 
                        	    28: ; Memory testing
                        	    29: START_ADDR_HIGH     = $10
                        	    30: END_ADDR_HIGH       = $11
                        	    31: BANK_TESTING        = $12
                        	    32: MEMORY_ADDR_TESTING = $14 ; 15
                        	    33: NR_OF_WORKING_RAM_BANKS = $16 ; 17
                        	    34: NR_OF_UNIQUE_RAM_BANKS  = $18 ; 19
                        	    35: BAD_VALUE           = $1A
                        	    36: 
                        	    37: TIMING_COUNTER      = $20 ; 21
                        	    38: COUNTER_IS_RUNNING  = $22
                        	    39: ESTIMATED_CPU_SPEED_PCM   = $23
                        	    40: ESTIMATED_CPU_SPEED_VSYNC = $24
                        	    41: 
                        	    42: ; Some RAM address locations we use
                        	    43: IRQ_RAM_ADDRES = $1000
                        	    44: ROM_TEST_CODE  = $4000
                        	    45: 
                        	    46: 
                        	    47:     .org $C000
                        	    48: 
                        	    49: reset:
                        	    50:     ; === Important: we start running using ROM only here, so there is no RAN/stack usage initially (no jsr, rts, or va
                        	    51: 
                        	    52:     ; Disable interrupts 
00:C000 78              	    53:     sei
                        	    54: 
                        	    55:     ; We enable VERA as soon as possible (and set it up), to give a sign of life (rom only)
                        	    56:     .include "utils/rom_only_setup_vera_for_tile_map.s"  

Source: "utils\rom_only_setup_vera_for_tile_map.s"
                        	     1: ; This sets up VERA for a tile map (8x8) in layer 0
                        	     2: ; It uses no RAM (ROM only)
                        	     3: 
                        	     4: TILE_MAP_WIDTH = 128
                        	     5: TILE_MAP_HEIGHT = 64
                        	     6: 
                        	     7:     ; -- First wait until VERA is ready
                        	     8:     
00:C001 A2A5            	     9:     ldx #$a5
                        	    10: wait_for_vera:
00:C003 A92A            	    11:     lda #42
00:C005 8D209F          	    12:     sta VERA_ADDR_LOW
                        	    13: 
00:C008 AD209F          	    14:     lda VERA_ADDR_LOW
00:C00B C92A            	    15:     cmp #42
00:C00D F00D            	    16:     beq vera_ready
00:C00F CA              	    17:     dex
00:C010 F039            	    18:     beq vera_tilemap_done   ; Give up, there is no VERA
                        	    19:     
00:C012 A000            	    20:     ldy #$00
                        	    21: vera_boot_snooze:           ; Short wait before checking VERA again
00:C014 EA              	    22:     nop
00:C015 EA              	    23:     nop
00:C016 C8              	    24:     iny
00:C017 D0FB            	    25:     bne vera_boot_snooze
00:C019 4C03C0          	    26:     jmp wait_for_vera
                        	    27: 
                        	    28: vera_ready:
                        	    29:     ; -- Show first sign of live by enabling VGA as soon as possible
                        	    30:   
00:C01C A911            	    31:     lda #%00010001           ; Enable Layer 0, Enable VGA
00:C01E 8D299F          	    32:     sta VERA_DC_VIDEO
                        	    33: 
00:C021 A900            	    34:     lda #0                   ; Set Horizontal and vertical scoll to 0
00:C023 8D309F          	    35:     sta VERA_L0_HSCROLL_L
00:C026 8D319F          	    36:     sta VERA_L0_HSCROLL_H
00:C029 8D329F          	    37:     sta VERA_L0_VSCROLL_L
00:C02C 8D339F          	    38:     sta VERA_L0_VSCROLL_H
                        	    39: 
00:C02F A980            	    40:     lda #$80                 ; 1:1 scale (640 x 480 pixels on screen)
00:C031 8D2A9F          	    41:     sta VERA_DC_HSCALE
00:C034 8D2B9F          	    42:     sta VERA_DC_VSCALE
                        	    43:     
00:C037 A900            	    44:     lda #%00000000           ; DCSEL=0, ADDRSEL=0
00:C039 8D259F          	    45:     sta VERA_CTRL
                        	    46:     
                        	    47:     ; TODO: use TILE_MAP_HEIGHT and TILE_MAP_WIDTH to determine this value!
00:C03C A9A0            	    48:     lda #%10100000           ; Set map height/width to 64/128, and Tile mode 1 bpp (16 color text mode)
00:C03E 8D2D9F          	    49:     sta VERA_L0_CONFIG
                        	    50:     
00:C041 A9D8            	    51:     lda #($1B0 >> 1)         ; Set mapbase for layer 0 to 0x1B000. This also sets the tile width and height to 8 px
00:C043 8D2E9F          	    52:     sta VERA_L0_MAPBASE
                        	    53:     
00:C046 A9F8            	    54:     lda #($1F0 >> 1)         ; Set tilebase for layer 0 to 0x1F000. This also sets the tile width and height to 8 px
00:C048 8D2F9F          	    55:     sta VERA_L0_TILEBASE
                        	    56: vera_tilemap_done:
                        	    57: 

Source: "x16_hardware_tester.s"
                        	    57: 
                        	    58:     ; Setup initial (rom only) screen and title
                        	    59:     .include "utils/rom_only_setup_screen.s"

Source: "utils\rom_only_setup_screen.s"
                        	     1: 
                        	     2:     ; === This file is for setup of palette colors, petscii charset, screen, title on screen, fixed ram header ===
                        	     3: 
                        	     4:     ; -- Change some colors in the palette
                        	     5:     
00:C04B A911            	     6:     lda #%00010001           ; Setting bit 16 of vram address to the highest bit in the tilebase (=1), setting auto-inc
00:C04D 8D229F          	     7:     sta VERA_ADDR_BANK
                        	     8:     
00:C050 A9FA            	     9:     lda #$FA
00:C052 8D219F          	    10:     sta VERA_ADDR_HIGH
00:C055 A908            	    11:     lda #$08                 ; We use color 4 in the pallete (each color takes 2 bytes)
00:C057 8D209F          	    12:     sta VERA_ADDR_LOW
                        	    13: 
00:C05A A905            	    14:     lda #$05                 ; gb
00:C05C 8D239F          	    15:     sta VERA_DATA0
00:C05F A905            	    16:     lda #$05                 ; -r
00:C061 8D239F          	    17:     sta VERA_DATA0
                        	    18:     
00:C064 A9FA            	    19:     lda #$FA
00:C066 8D219F          	    20:     sta VERA_ADDR_HIGH
00:C069 A904            	    21:     lda #$04                 ; We use color 2 in the pallete (each color takes 2 bytes)
00:C06B 8D209F          	    22:     sta VERA_ADDR_LOW
                        	    23: 
00:C06E A900            	    24:     lda #$00                 ; gb
00:C070 8D239F          	    25:     sta VERA_DATA0
00:C073 A90F            	    26:     lda #$0F                 ; -r
00:C075 8D239F          	    27:     sta VERA_DATA0
                        	    28:     
00:C078 A9FA            	    29:     lda #$FA
00:C07A 8D219F          	    30:     sta VERA_ADDR_HIGH
00:C07D A910            	    31:     lda #$10                 ; We use color 8 in the pallete (each color takes 2 bytes)
00:C07F 8D209F          	    32:     sta VERA_ADDR_LOW
                        	    33: 
00:C082 A980            	    34:     lda #$80                 ; gb
00:C084 8D239F          	    35:     sta VERA_DATA0
00:C087 A90F            	    36:     lda #$0F                 ; -r
00:C089 8D239F          	    37:     sta VERA_DATA0
                        	    38:     
                        	    39:     ; Copy petscii charset to VRAM
                        	    40:     .include "utils/rom_only_copy_petscii_charset.s"

Source: "utils\rom_only_copy_petscii_charset.s"
                        	     1: 
                        	     2:     ; -- Copy petscii charset to VRAM at $1F000-$1F7FF
                        	     3:     
00:C08C A911            	     4:     lda #%00010001           ; Setting bit 16 of vram address to the highest bit in the tilebase (=1), setting auto-inc
00:C08E 8D229F          	     5:     sta VERA_ADDR_BANK
                        	     6:     
00:C091 A9F0            	     7:     lda #$F0
00:C093 8D219F          	     8:     sta VERA_ADDR_HIGH
00:C096 A900            	     9:     lda #$00
00:C098 8D209F          	    10:     sta VERA_ADDR_LOW
                        	    11:     
00:C09B A000            	    12:     ldy #0
                        	    13: copy_petscii_0:
00:C09D B900F7          	    14:     lda petscii_0, y
00:C0A0 8D239F          	    15:     sta VERA_DATA0
00:C0A3 C8              	    16:     iny
00:C0A4 D0F7            	    17:     bne copy_petscii_0
                        	    18:     
00:C0A6 A000            	    19:     ldy #0
                        	    20: copy_petscii_1:
00:C0A8 B900F8          	    21:     lda petscii_1, y
00:C0AB 8D239F          	    22:     sta VERA_DATA0
00:C0AE C8              	    23:     iny
00:C0AF D0F7            	    24:     bne copy_petscii_1
                        	    25:     
00:C0B1 A000            	    26:     ldy #0
                        	    27: copy_petscii_2:
00:C0B3 B900F9          	    28:     lda petscii_2, y
00:C0B6 8D239F          	    29:     sta VERA_DATA0
00:C0B9 C8              	    30:     iny
00:C0BA D0F7            	    31:     bne copy_petscii_2
                        	    32:     
00:C0BC A000            	    33:     ldy #0
                        	    34: copy_petscii_3:
00:C0BE B900FA          	    35:     lda petscii_3, y
00:C0C1 8D239F          	    36:     sta VERA_DATA0
00:C0C4 C8              	    37:     iny
00:C0C5 D0F7            	    38:     bne copy_petscii_3
                        	    39:     
00:C0C7 A000            	    40:     ldy #0
                        	    41: copy_petscii_4:
00:C0C9 B900FB          	    42:     lda petscii_4, y
00:C0CC 8D239F          	    43:     sta VERA_DATA0
00:C0CF C8              	    44:     iny
00:C0D0 D0F7            	    45:     bne copy_petscii_4
                        	    46:     
00:C0D2 A000            	    47:     ldy #0
                        	    48: copy_petscii_5:
00:C0D4 B900FC          	    49:     lda petscii_5, y
00:C0D7 8D239F          	    50:     sta VERA_DATA0
00:C0DA C8              	    51:     iny
00:C0DB D0F7            	    52:     bne copy_petscii_5
                        	    53:     
00:C0DD A000            	    54:     ldy #0
                        	    55: copy_petscii_6:
00:C0DF B900FD          	    56:     lda petscii_6, y
00:C0E2 8D239F          	    57:     sta VERA_DATA0
00:C0E5 C8              	    58:     iny
00:C0E6 D0F7            	    59:     bne copy_petscii_6
                        	    60:     
00:C0E8 A000            	    61:     ldy #0
                        	    62: copy_petscii_7:
00:C0EA B900FE          	    63:     lda petscii_7, y
00:C0ED 8D239F          	    64:     sta VERA_DATA0
00:C0F0 C8              	    65:     iny
00:C0F1 D0F7            	    66:     bne copy_petscii_7
                        	    67: 

Source: "utils\rom_only_setup_screen.s"
                        	    41:     
                        	    42:     ; This will clear the screen without using RAM.
                        	    43: 
                        	    44:     ; -- Fill tilemap into VRAM at $1B000-$1EBFF
                        	    45: 
                        	    46: vera_clear_start:
00:C0F3 A911            	    47:     lda #%00010001           ; Setting bit 16 of vram address to the highest bit in the tilebase (=1), setting auto-inc
00:C0F5 8D229F          	    48:     sta VERA_ADDR_BANK
00:C0F8 A9B0            	    49:     lda #$B0
00:C0FA 8D219F          	    50:     sta VERA_ADDR_HIGH
00:C0FD A900            	    51:     lda #$00
00:C0FF 8D209F          	    52:     sta VERA_ADDR_LOW
                        	    53:     
00:C102 A020            	    54:     ldy #(TILE_MAP_HEIGHT / (256 / TILE_MAP_WIDTH))
                        	    55: vera_clear_fill_tile_map:
00:C104 A200            	    56:     ldx #0
                        	    57: vera_clear_fill_tile_map_row:
00:C106 A920            	    58:     lda #$20
00:C108 8D239F          	    59:     sta VERA_DATA0           ; character index = 'space'
00:C10B A941            	    60:     lda #COLOR_NORMAL
00:C10D 8D239F          	    61:     sta VERA_DATA0           ; Fill Foreground and background color
00:C110 E8              	    62:     inx
00:C111 D0F3            	    63:     bne vera_clear_fill_tile_map_row
00:C113 88              	    64:     dey
00:C114 D0EE            	    65:     bne vera_clear_fill_tile_map
                        	    66:     
                        	    67:     
                        	    68: ; --- This is printing the title
                        	    69:     
                        	    70: print_title:
00:C116 A911            	    71:     lda #%00010001           ; Setting bit 16 of vram address to the highest bit in the tilebase (=1), setting auto-inc
00:C118 8D229F          	    72:     sta VERA_ADDR_BANK
00:C11B A9B1            	    73:     lda #$B1
00:C11D 8D219F          	    74:     sta VERA_ADDR_HIGH
00:C120 A930            	    75:     lda #$30
00:C122 8D209F          	    76:     sta VERA_ADDR_LOW
                        	    77:     
00:C125 A200            	    78:     ldx #0
                        	    79: print_title_message:
00:C127 BD4FC1          	    80:     lda title_message, x
00:C12A F046            	    81:     beq done_print_title_message
00:C12C C961            	    82:     cmp #97  ; 'a'
00:C12E 100D            	    83:     bpl title_larger_than_or_equal_to_a
                        	    84: title_smaller_than_a:            
00:C130 C941            	    85:     cmp #65  ; 'A'
00:C132 1003            	    86:     bpl title_between_A_and_a
                        	    87:     ; This part is roughly the same between ASCII and PETSCII
00:C134 4C43C1          	    88:     jmp title_char_convert_done
                        	    89: title_between_A_and_a:           ; Uppercase letters
00:C137 38              	    90:     sec
00:C138 E940            	    91:     sbc #64
00:C13A 4C43C1          	    92:     jmp title_char_convert_done
                        	    93: title_larger_than_or_equal_to_a: ; Lowercase letters
00:C13D 38              	    94:     sec
00:C13E E960            	    95:     sbc #96
00:C140 18              	    96:     clc
00:C141 6980            	    97:     adc #128
                        	    98: title_char_convert_done:  
00:C143 E8              	    99:     inx
00:C144 8D239F          	   100:     sta VERA_DATA0
00:C147 A943            	   101:     lda #COLOR_TITLE
00:C149 8D239F          	   102:     sta VERA_DATA0           
00:C14C 4C27C1          	   103:     jmp print_title_message
                        	   104:     
                        	   105: title_message:
00:C14F 2A2A2A2058313620	   106:     .asciiz "*** X16 Hardware Tester v0.3.0 ***"
00:C157 4861726477617265
00:C15F 2054657374657220
00:C167 76302E332E30202A
00:C16F 2A2A
00:C171 00
                        	   107: 
                        	   108: done_print_title_message:
                        	   109:     
                        	   110:     
                        	   111: ; --- This is printing the Fixed RAM header
                        	   112:     
                        	   113: print_fixed_ram_header:
00:C172 A911            	   114:     lda #%00010001           ; Setting bit 16 of vram address to the highest bit in the tilebase (=1), setting auto-inc
00:C174 8D229F          	   115:     sta VERA_ADDR_BANK
00:C177 A9B3            	   116:     lda #$B3
00:C179 8D219F          	   117:     sta VERA_ADDR_HIGH
00:C17C A904            	   118:     lda #($00+MARGIN*2)
00:C17E 8D209F          	   119:     sta VERA_ADDR_LOW
                        	   120:     
00:C181 A200            	   121:     ldx #0
                        	   122: print_fixed_ram_message:
00:C183 BDE6C6          	   123:     lda fixed_ram_header_message, x
00:C186 F023            	   124:     beq done_print_fixed_ram_message
00:C188 C961            	   125:     cmp #97  ; 'a'
00:C18A 100D            	   126:     bpl fixed_ram_larger_than_or_equal_to_a
                        	   127: fixed_ram_smaller_than_a:            
00:C18C C941            	   128:     cmp #65  ; 'A'
00:C18E 1003            	   129:     bpl fixed_ram_between_A_and_a
                        	   130:     ; This part is roughly the same between ASCII and PETSCII
00:C190 4C9FC1          	   131:     jmp fixed_ram_char_convert_done
                        	   132: fixed_ram_between_A_and_a:           ; Uppercase letters
00:C193 38              	   133:     sec
00:C194 E940            	   134:     sbc #64
00:C196 4C9FC1          	   135:     jmp fixed_ram_char_convert_done
                        	   136: fixed_ram_larger_than_or_equal_to_a: ; Lowercase letters
00:C199 38              	   137:     sec
00:C19A E960            	   138:     sbc #96
00:C19C 18              	   139:     clc
00:C19D 6980            	   140:     adc #128
                        	   141: fixed_ram_char_convert_done:  
00:C19F E8              	   142:     inx
00:C1A0 8D239F          	   143:     sta VERA_DATA0
00:C1A3 A947            	   144:     lda #COLOR_HEADER
00:C1A5 8D239F          	   145:     sta VERA_DATA0           
00:C1A8 4C83C1          	   146:     jmp print_fixed_ram_message
                        	   147:     
                        	   148: done_print_fixed_ram_message:
                        	   149:     
                        	   150: 

Source: "x16_hardware_tester.s"
                        	    60: 
                        	    61:     ; Test Zero Page and Stack RAM once
                        	    62:     .include "tests/rom_only_test_zp_and_stack_ram_once.s"

Source: "tests\rom_only_test_zp_and_stack_ram_once.s"
                        	     1: ; This is a single test for the Zero page and stack memory in the X16
                        	     2: ; This memory spans from $0002 to $01FF 
                        	     3: ; Note that addresses $0000 and $0001 are special addresses and should NOT be regarded as RAM here (and are -for now- s
                        	     4: 
                        	     5: ram_block_0 = $0000
                        	     6: ram_block_1 = $0100
                        	     7: 
                        	     8: print_testing_zp_stack_ram:
00:C1AB A911            	     9:     lda #%00010001           ; Setting bit 16 of vram address to the highest bit in the tilebase (=1), setting auto-inc
00:C1AD 8D229F          	    10:     sta VERA_ADDR_BANK
00:C1B0 A9B4            	    11:     lda #$B4
00:C1B2 8D219F          	    12:     sta VERA_ADDR_HIGH
00:C1B5 A908            	    13:     lda #($00+MARGIN*2+INDENT_SIZE*2)
00:C1B7 8D209F          	    14:     sta VERA_ADDR_LOW
                        	    15:     
00:C1BA A200            	    16:     ldx #0
                        	    17: print_testing_message:
00:C1BC BDE7C1          	    18:     lda testing_message, x
00:C1BF F023            	    19:     beq done_print_testing_message
00:C1C1 C961            	    20:     cmp #97  ; 'a'
00:C1C3 100D            	    21:     bpl larger_than_or_equal_to_a
                        	    22: smaller_than_a:            
00:C1C5 C941            	    23:     cmp #65  ; 'A'
00:C1C7 1003            	    24:     bpl between_A_and_a
                        	    25:     ; This part is roughly the same between ASCII and PETSCII
00:C1C9 4CD8C1          	    26:     jmp char_convert_done
                        	    27: between_A_and_a:           ; Uppercase letters
00:C1CC 38              	    28:     sec
00:C1CD E940            	    29:     sbc #64
00:C1CF 4CD8C1          	    30:     jmp char_convert_done
                        	    31: larger_than_or_equal_to_a: ; Lowercase letters
00:C1D2 38              	    32:     sec
00:C1D3 E960            	    33:     sbc #96
00:C1D5 18              	    34:     clc
00:C1D6 6980            	    35:     adc #128
                        	    36: char_convert_done:  
00:C1D8 E8              	    37:     inx
00:C1D9 8D239F          	    38:     sta VERA_DATA0
00:C1DC A941            	    39:     lda #$41                 ; Background color 4, foreground color 1
00:C1DE 8D239F          	    40:     sta VERA_DATA0           
00:C1E1 4CBCC1          	    41:     jmp print_testing_message
                        	    42:     
                        	    43: done_print_testing_message:
00:C1E4 4C1FC2          	    44:     jmp test_zp_stack_ram_start
                        	    45:     
                        	    46: testing_message: 
00:C1E7 54657374696E6720	    47:     .asciiz "Testing zero page and stack memory ($0002 - $01FF) ... "
00:C1EF 7A65726F20706167
00:C1F7 6520616E64207374
00:C1FF 61636B206D656D6F
00:C207 7279202824303030
00:C20F 32202D2024303146
00:C217 4629202E2E2E20
00:C21E 00
                        	    48: 
                        	    49: test_zp_stack_ram_start:
                        	    50: 
00:C21F A000            	    51:     ldy #0                        ; y represents the high byte of the address (0 for $0002 - $00FF)
                        	    52:     
00:C221 A202            	    53:     ldx #2                        ; Skipping $0000 and $0001
                        	    54: check_ram_block_0_FF:
00:C223 A9FF            	    55:     lda #$FF
00:C225 9500            	    56:     sta ram_block_0, x
00:C227 B500            	    57:     lda ram_block_0, x
00:C229 C9FF            	    58:     cmp #$FF
00:C22B D039            	    59:     bne zp_stack_ram_is_not_ok
00:C22D E8              	    60:     inx
00:C22E D0F3            	    61:     bne check_ram_block_0_FF
                        	    62:     
00:C230 A202            	    63:     ldx #2                        ; Skipping $0000 and $0001
                        	    64: check_ram_block_0_00:
00:C232 A900            	    65:     lda #$00
00:C234 9500            	    66:     sta ram_block_0, x
00:C236 B500            	    67:     lda ram_block_0, x
00:C238 C900            	    68:     cmp #$00
00:C23A D02A            	    69:     bne zp_stack_ram_is_not_ok
00:C23C E8              	    70:     inx
00:C23D D0F3            	    71:     bne check_ram_block_0_00
                        	    72:     
00:C23F A001            	    73:     ldy #1                        ; y represents the high byte of the address (1 for $0100 - $01FF)
                        	    74:     
00:C241 A200            	    75:     ldx #0
                        	    76: check_ram_block_1_FF:
00:C243 A9FF            	    77:     lda #$FF
00:C245 9D0001          	    78:     sta ram_block_1, x
00:C248 BD0001          	    79:     lda ram_block_1, x
00:C24B C9FF            	    80:     cmp #$FF
00:C24D D017            	    81:     bne zp_stack_ram_is_not_ok
00:C24F E8              	    82:     inx
00:C250 D0F1            	    83:     bne check_ram_block_1_FF
                        	    84:     
00:C252 A200            	    85:     ldx #0
                        	    86: check_ram_block_1_00:
00:C254 A900            	    87:     lda #$00
00:C256 9D0001          	    88:     sta ram_block_1, x
00:C259 BD0001          	    89:     lda ram_block_1, x
00:C25C C900            	    90:     cmp #$00
00:C25E D006            	    91:     bne zp_stack_ram_is_not_ok
00:C260 E8              	    92:     inx
00:C261 D0F1            	    93:     bne check_ram_block_1_00
                        	    94:     
                        	    95: zp_stack_done_checking_ram:
00:C263 4C65C3          	    96:     jmp zp_stack_ram_is_ok
                        	    97:     
                        	    98: zp_stack_ram_is_not_ok:
                        	    99:     ; Currently used to trigger an LA
00:C266 8D609F          	   100:     sta IO3_BASE_ADDRESS
                        	   101: 
                        	   102:     ; WORKAROUND: when testing Fixed RAM we do NOT want to use Fixed RAM for running the test itself (like the Stack or
                        	   103:     ; But in this case want want to preserve all CPU registers: X, Y and A. We want to print them to screen. We somehow
                        	   104:     ; So for now, we put it into a VERA-register we are not using (VERA_L1_HSCROLL_L in this case).
00:C269 8D379F          	   105:     sta VERA_L1_HSCROLL_L
                        	   106: 
00:C26C A90E            	   107:     lda #('N'-64)
00:C26E 8D239F          	   108:     sta VERA_DATA0
00:C271 A942            	   109:     lda #$42                 ; Background color 4, foreground color 2
00:C273 8D239F          	   110:     sta VERA_DATA0             
00:C276 A90F            	   111:     lda #('O'-64)
00:C278 8D239F          	   112:     sta VERA_DATA0
00:C27B A942            	   113:     lda #$42                 ; Background color 4, foreground color 2
00:C27D 8D239F          	   114:     sta VERA_DATA0             
00:C280 A914            	   115:     lda #('T'-64)
00:C282 8D239F          	   116:     sta VERA_DATA0
00:C285 A942            	   117:     lda #$42                 ; Background color 4, foreground color 2
00:C287 8D239F          	   118:     sta VERA_DATA0           
00:C28A A920            	   119:     lda #' '
00:C28C 8D239F          	   120:     sta VERA_DATA0
00:C28F A942            	   121:     lda #$42                 ; Background color 4, foreground color 2
00:C291 8D239F          	   122:     sta VERA_DATA0           
00:C294 A90F            	   123:     lda #('O'-64)
00:C296 8D239F          	   124:     sta VERA_DATA0
00:C299 A942            	   125:     lda #$42                 ; Background color 4, foreground color 2
00:C29B 8D239F          	   126:     sta VERA_DATA0             
00:C29E A90B            	   127:     lda #('K'-64)
00:C2A0 8D239F          	   128:     sta VERA_DATA0
00:C2A3 A942            	   129:     lda #$42                 ; Background color 4, foreground color 2
00:C2A5 8D239F          	   130:     sta VERA_DATA0
                        	   131: 
00:C2A8 A920            	   132:     lda #' '
00:C2AA 8D239F          	   133:     sta VERA_DATA0
00:C2AD A942            	   134:     lda #$42                 ; Background color 4, foreground color 2
00:C2AF 8D239F          	   135:     sta VERA_DATA0           
00:C2B2 A928            	   136:     lda #'('
00:C2B4 8D239F          	   137:     sta VERA_DATA0
00:C2B7 A942            	   138:     lda #$42                 ; Background color 4, foreground color 2
00:C2B9 8D239F          	   139:     sta VERA_DATA0           
00:C2BC A924            	   140:     lda #'$'
00:C2BE 8D239F          	   141:     sta VERA_DATA0
00:C2C1 A942            	   142:     lda #$42                 ; Background color 4, foreground color 2
00:C2C3 8D239F          	   143:     sta VERA_DATA0           
00:C2C6 A930            	   144:     lda #'0'
00:C2C8 8D239F          	   145:     sta VERA_DATA0
00:C2CB A942            	   146:     lda #$42                 ; Background color 4, foreground color 2
00:C2CD 8D239F          	   147:     sta VERA_DATA0           
                        	   148:     
00:C2D0 98              	   149:     tya
00:C2D1 18              	   150:     clc
00:C2D2 6930            	   151:     adc #'0'
00:C2D4 8D239F          	   152:     sta VERA_DATA0
00:C2D7 A942            	   153:     lda #$42                 ; Background color 4, foreground color 2
00:C2D9 8D239F          	   154:     sta VERA_DATA0           
                        	   155: 
                        	   156: 
                        	   157:     ; Show high address nibble
00:C2DC 8A              	   158:     txa
00:C2DD 4A              	   159:     lsr
00:C2DE 4A              	   160:     lsr
00:C2DF 4A              	   161:     lsr
00:C2E0 4A              	   162:     lsr
00:C2E1 C90A            	   163:     cmp #10
00:C2E3 1006            	   164:     bpl zp_stack_high_nibble_is_larger_than_or_equal_to_10
00:C2E5 18              	   165:     clc
00:C2E6 6930            	   166:     adc #'0'
00:C2E8 4CEEC2          	   167:     jmp zp_stack_high_nibble_ready
                        	   168: zp_stack_high_nibble_is_larger_than_or_equal_to_10:
00:C2EB 38              	   169:     sec
00:C2EC E909            	   170:     sbc #9
                        	   171: zp_stack_high_nibble_ready:
00:C2EE 8D239F          	   172:     sta VERA_DATA0
00:C2F1 A942            	   173:     lda #$42                 ; Background color 4, foreground color 2
00:C2F3 8D239F          	   174:     sta VERA_DATA0
                        	   175:     
                        	   176:     ; Show low address nibble
00:C2F6 8A              	   177:     txa
00:C2F7 290F            	   178:     and #$0f
00:C2F9 C90A            	   179:     cmp #10
00:C2FB 1006            	   180:     bpl zp_stack_low_nibble_is_larger_than_or_equal_to_10
00:C2FD 18              	   181:     clc
00:C2FE 6930            	   182:     adc #'0'
00:C300 4C06C3          	   183:     jmp zp_stack_low_nibble_ready
                        	   184: zp_stack_low_nibble_is_larger_than_or_equal_to_10:
00:C303 38              	   185:     sec
00:C304 E909            	   186:     sbc #9
                        	   187: zp_stack_low_nibble_ready:
00:C306 8D239F          	   188:     sta VERA_DATA0
00:C309 A942            	   189:     lda #$42                 ; Background color 4, foreground color 2
00:C30B 8D239F          	   190:     sta VERA_DATA0
                        	   191: 
                        	   192: 
00:C30E A93D            	   193:     lda #'='
00:C310 8D239F          	   194:     sta VERA_DATA0
00:C313 A942            	   195:     lda #$42                 ; Background color 4, foreground color 2
00:C315 8D239F          	   196:     sta VERA_DATA0           
00:C318 A924            	   197:     lda #'$'
00:C31A 8D239F          	   198:     sta VERA_DATA0
00:C31D A942            	   199:     lda #$42                 ; Background color 4, foreground color 2
00:C31F 8D239F          	   200:     sta VERA_DATA0           
                        	   201: 
                        	   202:     ; Show high data nibble
00:C322 AD379F          	   203:     lda VERA_L1_HSCROLL_L    ; See comment above regarding WORKAROUND
00:C325 4A              	   204:     lsr
00:C326 4A              	   205:     lsr
00:C327 4A              	   206:     lsr
00:C328 4A              	   207:     lsr
00:C329 C90A            	   208:     cmp #10
00:C32B 1006            	   209:     bpl zp_stack_high_data_nibble_is_larger_than_or_equal_to_10
00:C32D 18              	   210:     clc
00:C32E 6930            	   211:     adc #'0'
00:C330 4C36C3          	   212:     jmp zp_stack_high_data_nibble_ready
                        	   213: zp_stack_high_data_nibble_is_larger_than_or_equal_to_10:
00:C333 38              	   214:     sec
00:C334 E909            	   215:     sbc #9
                        	   216: zp_stack_high_data_nibble_ready:
00:C336 8D239F          	   217:     sta VERA_DATA0
00:C339 A942            	   218:     lda #$42                 ; Background color 4, foreground color 2
00:C33B 8D239F          	   219:     sta VERA_DATA0
                        	   220:     
                        	   221:     ; Show low data nibble
00:C33E AD379F          	   222:     lda VERA_L1_HSCROLL_L    ; See comment above regarding WORKAROUND
00:C341 290F            	   223:     and #$0f
00:C343 C90A            	   224:     cmp #10
00:C345 1006            	   225:     bpl zp_stack_low_data_nibble_is_larger_than_or_equal_to_10
00:C347 18              	   226:     clc
00:C348 6930            	   227:     adc #'0'
00:C34A 4C50C3          	   228:     jmp zp_stack_low_data_nibble_ready
                        	   229: zp_stack_low_data_nibble_is_larger_than_or_equal_to_10:
00:C34D 38              	   230:     sec
00:C34E E909            	   231:     sbc #9
                        	   232: zp_stack_low_data_nibble_ready:
00:C350 8D239F          	   233:     sta VERA_DATA0
00:C353 A942            	   234:     lda #$42                 ; Background color 4, foreground color 2
00:C355 8D239F          	   235:     sta VERA_DATA0
                        	   236:     
00:C358 A929            	   237:     lda #')'
00:C35A 8D239F          	   238:     sta VERA_DATA0
00:C35D A942            	   239:     lda #$42                 ; Background color 4, foreground color 2
00:C35F 8D239F          	   240:     sta VERA_DATA0           
                        	   241:     
                        	   242:     ; TODO: we should probably move on after this somehow. For now we are halting.
                        	   243:     
                        	   244: zp_stack_loop_ram_not_ok:
00:C362 4C62C3          	   245:     jmp zp_stack_loop_ram_not_ok
                        	   246:     
                        	   247: zp_stack_ram_is_ok:
00:C365 A90F            	   248:     lda #('O'-64)
00:C367 8D239F          	   249:     sta VERA_DATA0
00:C36A A945            	   250:     lda #$45                 ; Background color 4, foreground color 5 (green)
00:C36C 8D239F          	   251:     sta VERA_DATA0             
00:C36F A90B            	   252:     lda #('K'-64)
00:C371 8D239F          	   253:     sta VERA_DATA0
00:C374 A945            	   254:     lda #$45                 ; Background color 4, foreground color 5 (green)
00:C376 8D239F          	   255:     sta VERA_DATA0           
                        	   256: 

Source: "x16_hardware_tester.s"
                        	    63: 
                        	    64:     ; === Zero page and stack memory checks out OK, we can now use it ===
                        	    65: 
                        	    66:     ; Setup stack
00:C379 A2FF            	    67:     ldx #$ff
00:C37B 9A              	    68:     txs
                        	    69: 
                        	    70:     ; Init cursor for printing to screen
00:C37C A904            	    71:     lda #(MARGIN+INDENT_SIZE)
00:C37E 850B            	    72:     sta INDENTATION
00:C380 8509            	    73:     sta CURSOR_X
00:C382 A905            	    74:     lda #5          ; We already printed a title, a header and one line when testing Zero page and stack memory
00:C384 850A            	    75:     sta CURSOR_Y
                        	    76: 
                        	    77:     ; === Fixed RAM ===
                        	    78:     ; Note: We already printed the header in rom-only mode
                        	    79:     
                        	    80:     ; Test Fixed RAM
00:C386 2018C7          	    81:     jsr test_fixed_ram
                        	    82: 
                        	    83:     ; === Banked RAM ===
00:C389 20F3C7          	    84:     jsr print_banked_ram_header
                        	    85:     
                        	    86:     ; Measure the amount of banked RAM
00:C38C 20A4C8          	    87:     jsr determine_nr_of_ram_banks
                        	    88:     
                        	    89:     ; Based on the number of unique ram banks, we check those ram banks (every byte in it)
00:C38F 2015C8          	    90:     jsr test_banked_ram 
                        	    91:     
                        	    92:     ; === Banked ROM ===
00:C392 20A8C9          	    93:     jsr print_banked_rom_header
                        	    94:     
                        	    95:     ; We filled all ROM banks with incrementing numbers and check these with a program in RAM
00:C395 20CAC9          	    96:     jsr test_rom_banks
                        	    97: 
                        	    98:     ; === VERA SD ===
00:C398 2027CF          	    99:     jsr print_vera_sd_header
                        	   100:     
                        	   101:     ; Try to detect/reset the SD card
00:C39B 20BCCF          	   102:     jsr vera_reset_sd_card
00:C39E 900A            	   103:     bcc done_with_sd_checks   ; If card was not detected (or there was some error) we do not proceed with SD Card tests
                        	   104:     
                        	   105:     ; Check if card is SDC Ver.2+
00:C3A0 2024D0          	   106:     jsr vera_check_sdc_version
00:C3A3 9005            	   107:     bcc done_with_sd_checks   ; If card was SDC Ver.2+ we do not proceed with SD Card tests
                        	   108:     
                        	   109:     ; Initialize SD card
00:C3A5 2049CF          	   110:     jsr vera_initialize_sd_card
00:C3A8 9000            	   111:     bcc done_with_sd_checks   ; If card was not propely initialized we do not proceed with SD Card tests
                        	   112:     
                        	   113:     ; TODO: read MBR sector and test/show results!
                        	   114:     
                        	   115: done_with_sd_checks:
                        	   116: 
                        	   117: ; FIXME: there is something VERY WEIRD: when I put the VERA Video code BEFORE the VERA SD code the pcm speed test will 
                        	   118: 
                        	   119:     ; === VERA Video ===
00:C3AA 2032CB          	   120:     jsr print_vera_video_header
                        	   121:     
                        	   122:     ; Test VRAM (read/write)
00:C3AD 2057CB          	   123:     jsr test_vram
                        	   124: 
                        	   125:     ; Use PCM FIFO buffer to measure CPU speed
00:C3B0 2003CD          	   126:     jsr measure_cpu_speed_using_pcm
                        	   127:     
                        	   128:     ; Use V-sync irqs to measure CPU speed
00:C3B3 20B5CD          	   129:     jsr measure_cpu_speed_using_vsync
                        	   130:     
                        	   131:     
                        	   132:     
                        	   133: loop:
                        	   134:     ; TODO: wait for (keyboard) input
00:C3B6 4CB6C3          	   135:     jmp loop
                        	   136: 
                        	   137:     
                        	   138:     ; === Included files ===
                        	   139:     
                        	   140:     .include utils/x16.s

Source: "utils\x16.s"
                        	     1: ; X16 constants
                        	     2: 
                        	     3: VERA_ADDR_LOW     = $9F20
                        	     4: VERA_ADDR_HIGH    = $9F21
                        	     5: VERA_ADDR_BANK    = $9F22
                        	     6: VERA_DATA0        = $9F23
                        	     7: VERA_DATA1        = $9F24
                        	     8: VERA_CTRL         = $9F25
                        	     9: 
                        	    10: VERA_IEN          = $9F26
                        	    11: VERA_ISR          = $9F27
                        	    12: VERA_IRQLINE_L    = $9F28
                        	    13: 
                        	    14: VERA_DC_VIDEO     = $9F29  ; DCSEL=0
                        	    15: VERA_DC_HSCALE    = $9F2A  ; DCSEL=0
                        	    16: VERA_DC_VSCALE    = $9F2B  ; DCSEL=0
                        	    17: VERA_DC_BORDER    = $9F2C  ; DCSEL=0
                        	    18: 
                        	    19: VERA_DC_HSTART    = $9F29  ; DCSEL=1
                        	    20: VERA_DC_HSTOP     = $9F2A  ; DCSEL=1
                        	    21: VERA_DC_VSTART    = $9F2B  ; DCSEL=1
                        	    22: VERA_DC_VSTOP     = $9F2C  ; DCSEL=1
                        	    23: 
                        	    24: VERA_L0_CONFIG    = $9F2D
                        	    25: VERA_L0_MAPBASE   = $9F2E
                        	    26: VERA_L0_TILEBASE  = $9F2F
                        	    27: VERA_L0_HSCROLL_L = $9F30
                        	    28: VERA_L0_HSCROLL_H = $9F31
                        	    29: VERA_L0_VSCROLL_L = $9F32
                        	    30: VERA_L0_VSCROLL_H = $9F33
                        	    31: 
                        	    32: VERA_L1_CONFIG    = $9F34
                        	    33: VERA_L1_MAPBASE   = $9F35
                        	    34: VERA_L1_TILEBASE  = $9F36
                        	    35: VERA_L1_HSCROLL_L = $9F37
                        	    36: VERA_L1_HSCROLL_H = $9F38
                        	    37: VERA_L1_VSCROLL_L = $9F39
                        	    38: VERA_L1_VSCROLL_H = $9F3A
                        	    39: 
                        	    40: VERA_AUDIO_CTRL   = $9F3B
                        	    41: VERA_AUDIO_RATE   = $9F3C
                        	    42: VERA_AUDIO_DATA   = $9F3D
                        	    43: 
                        	    44: VERA_SPI_DATA     = $9F3E
                        	    45: VERA_SPI_CTRL     = $9F3F
                        	    46: 
                        	    47: VERA_PALETTE      = $1FA00
                        	    48: 
                        	    49: VIA1_PORTB        = $9F00
                        	    50: VIA1_PORTA        = $9F01
                        	    51: VIA1_DDRB         = $9F02
                        	    52: VIA1_DDRA         = $9F03
                        	    53: 
                        	    54: ; This is currently used to trigger an LA
                        	    55: IO3_BASE_ADDRESS  = $9F60
                        	    56: 
                        	    57: 

Source: "x16_hardware_tester.s"
                        	   141:     .include utils/utils.s

Source: "utils\utils.s"
                        	     1: 
                        	     2: ; Print margins
                        	     3: MARGIN          = 2
                        	     4: INDENT_SIZE     = 2
                        	     5: 
                        	     6: ; Colors
                        	     7: COLOR_TITLE        = $43 ; Background color = 4, foreground color 3 (cyan)
                        	     8: COLOR_NORMAL       = $41 ; Background color = 4, foreground color 1 (white)
                        	     9: COLOR_HEADER       = $47 ; Background color = 4, foreground color 7 (yellow)
                        	    10: COLOR_OK           = $45 ; Background color = 4, foreground color 5 (green)
                        	    11: COLOR_ERROR        = $42 ; Background color = 4, foreground color 2 (red)
                        	    12: COLOR_WARNING      = $48 ; Background color = 4, foreground color 8 (orange)
                        	    13: 
                        	    14: ok_message: 
00:C3B9 4F4B            	    15:     .asciiz "OK"
00:C3BB 00
                        	    16: not_ok_message: 
00:C3BC 4E4F54204F4B    	    17:     .asciiz "NOT OK"
00:C3C2 00
                        	    18: spi_command_error: 
00:C3C3 4E4F54204F4B2028	    19:     .asciiz "NOT OK (CMD"
00:C3CB 434D44
00:C3CE 00
                        	    20: 
                        	    21: move_cursor_to_next_line:
00:C3CF 48              	    22:     pha
                        	    23: 
00:C3D0 A50B            	    24:     lda INDENTATION
00:C3D2 8509            	    25:     sta CURSOR_X
00:C3D4 E60A            	    26:     inc CURSOR_Y
                        	    27: 
00:C3D6 68              	    28:     pla
00:C3D7 60              	    29:     rts
                        	    30: 
                        	    31: setup_cursor:
00:C3D8 A911            	    32:     lda #%00010001           ; Setting bit 16 of vram address to the highest bit in the tilebase (=1), setting auto-inc
00:C3DA 8D229F          	    33:     sta VERA_ADDR_BANK
00:C3DD A9B0            	    34:     lda #$B0
00:C3DF 18              	    35:     clc
00:C3E0 650A            	    36:     adc CURSOR_Y             ; this assumes TILE_MAP_WIDTH = 128 (and each tile takes 2 bytes, so we add $100 for each 
00:C3E2 8D219F          	    37:     sta VERA_ADDR_HIGH
00:C3E5 A509            	    38:     lda CURSOR_X
00:C3E7 0A              	    39:     asl                      ; each tile takes to bytes, so we shift to the left once
00:C3E8 8D209F          	    40:     sta VERA_ADDR_LOW
00:C3EB 60              	    41:     rts
                        	    42: 
                        	    43: 
                        	    44: ; -- Prints a zero-terminated string
                        	    45: ;
                        	    46: ; TEXT_TO_PRINT : address containing the ASCII text to print
                        	    47: ; TEXT_COLOR : two nibbles containing the background and foreground color of the text
                        	    48: ; CURSOR_X : the x-position of the cursor to start printing
                        	    49: ; CURSOR_Y : the y-position of the cursor to start printing (assuming TILE_MAP_WIDTH = 128)
                        	    50: ;
                        	    51: print_text_zero:
00:C3EC 48              	    52:     pha
00:C3ED 98              	    53:     tya
00:C3EE 48              	    54:     pha
                        	    55: 
00:C3EF 20D8C3          	    56:     jsr setup_cursor
                        	    57: 
00:C3F2 A000            	    58:     ldy #0
                        	    59: print_next_char:
00:C3F4 B106            	    60:     lda (TEXT_TO_PRINT), y
00:C3F6 F023            	    61:     beq done_print_text
00:C3F8 C961            	    62:     cmp #97  ; 'a'
00:C3FA 100D            	    63:     bpl char_larger_than_or_equal_to_a
                        	    64: char_smaller_than_a:            
00:C3FC C941            	    65:     cmp #65  ; 'A'
00:C3FE 1003            	    66:     bpl char_between_A_and_a
                        	    67:     ; This part is roughly the same between ASCII and PETSCII
00:C400 4C0FC4          	    68:     jmp char_conversion_done
                        	    69: char_between_A_and_a:           ; Uppercase letters
00:C403 38              	    70:     sec
00:C404 E940            	    71:     sbc #64
00:C406 4C0FC4          	    72:     jmp char_conversion_done
                        	    73: char_larger_than_or_equal_to_a: ; Lowercase letters
00:C409 38              	    74:     sec
00:C40A E960            	    75:     sbc #96
00:C40C 18              	    76:     clc
00:C40D 6980            	    77:     adc #128
                        	    78: char_conversion_done:
00:C40F C8              	    79:     iny
00:C410 8D239F          	    80:     sta VERA_DATA0
00:C413 A508            	    81:     lda TEXT_COLOR                 ; Background color is high nibble, foreground color is low nibble
00:C415 8D239F          	    82:     sta VERA_DATA0           
00:C418 4CF4C3          	    83:     jmp print_next_char
                        	    84:   
                        	    85: done_print_text:
                        	    86: 
00:C41B 18              	    87:     clc
00:C41C 98              	    88:     tya
00:C41D 6509            	    89:     adc CURSOR_X
00:C41F 8509            	    90:     sta CURSOR_X
                        	    91: 
00:C421 68              	    92:     pla
00:C422 A8              	    93:     tay
00:C423 68              	    94:     pla
                        	    95: 
00:C424 60              	    96:     rts
                        	    97:     
                        	    98: 
                        	    99: print_byte_as_decimal:
                        	   100: 
00:C425 850C            	   101:     sta BYTE_TO_PRINT
00:C427 20D8C3          	   102:     jsr setup_cursor
                        	   103:     
00:C42A A50C            	   104:     lda BYTE_TO_PRINT
                        	   105:     
00:C42C 2075C4          	   106:     jsr mod10
00:C42F 18              	   107:     clc
00:C430 6930            	   108:     adc #'0'
00:C432 850F            	   109:     sta DECIMAL_STRING+2
00:C434 8A              	   110:     txa
00:C435 2075C4          	   111:     jsr mod10
00:C438 18              	   112:     clc
00:C439 6930            	   113:     adc #'0'
00:C43B 850E            	   114:     sta DECIMAL_STRING+1
00:C43D 8A              	   115:     txa
00:C43E 2075C4          	   116:     jsr mod10
00:C441 18              	   117:     clc
00:C442 6930            	   118:     adc #'0'
00:C444 850D            	   119:     sta DECIMAL_STRING
                        	   120:     
00:C446 A50C            	   121:     lda BYTE_TO_PRINT
00:C448 C90A            	   122:     cmp #10
00:C44A 901C            	   123:     bcc print_ones
00:C44C C964            	   124:     cmp #100
00:C44E 900C            	   125:     bcc print_tens
                        	   126:     
                        	   127: print_hundreds:
00:C450 A50D            	   128:     lda DECIMAL_STRING
00:C452 8D239F          	   129:     sta VERA_DATA0
00:C455 A508            	   130:     lda TEXT_COLOR
00:C457 8D239F          	   131:     sta VERA_DATA0
00:C45A E609            	   132:     inc CURSOR_X
                        	   133: print_tens:
00:C45C A50E            	   134:     lda DECIMAL_STRING+1
00:C45E 8D239F          	   135:     sta VERA_DATA0
00:C461 A508            	   136:     lda TEXT_COLOR
00:C463 8D239F          	   137:     sta VERA_DATA0
00:C466 E609            	   138:     inc CURSOR_X
                        	   139: print_ones:
00:C468 A50F            	   140:     lda DECIMAL_STRING+2
00:C46A 8D239F          	   141:     sta VERA_DATA0
00:C46D A508            	   142:     lda TEXT_COLOR
00:C46F 8D239F          	   143:     sta VERA_DATA0
00:C472 E609            	   144:     inc CURSOR_X
                        	   145:     
00:C474 60              	   146:     rts
                        	   147: 
                        	   148: 
                        	   149: ; modulus 10 a byte
                        	   150: ; Input
                        	   151: ;   a : byte to do modulus once
                        	   152: ; Result
                        	   153: ;   a : a % 10
                        	   154: ;   x : a / 10
                        	   155: mod10:
                        	   156:     ; TODO: This is not a good way of doing a mod10, make it better someday
00:C475 8503            	   157:     sta TMP2
                        	   158: 
                        	   159:     ; Divide by 10 ( from: https://codebase64.org/doku.php?id=base:8bit_divide_by_constant_8bit_result )
00:C477 4A              	   160:     lsr
00:C478 8502            	   161:     sta  TMP1
00:C47A 4A              	   162:     lsr
00:C47B 6502            	   163:     adc  TMP1
00:C47D 6A              	   164:     ror
00:C47E 4A              	   165:     lsr
00:C47F 4A              	   166:     lsr
00:C480 6502            	   167:     adc  TMP1
00:C482 6A              	   168:     ror
00:C483 6502            	   169:     adc  TMP1
00:C485 6A              	   170:     ror
00:C486 4A              	   171:     lsr
00:C487 4A              	   172:     lsr
                        	   173:     
00:C488 8502            	   174:     sta TMP1  ; number divided by 10 is in TMP1
00:C48A AA              	   175:     tax      ; a = a / 10
                        	   176:     
                        	   177:     ; We multiply the divided number by 10 again
                        	   178:     
00:C48B 0A              	   179:     asl
00:C48C 0A              	   180:     asl
00:C48D 0A              	   181:     asl      ; * 8
00:C48E 0602            	   182:     asl TMP1 ; * 2
00:C490 18              	   183:     clc
00:C491 6502            	   184:     adc TMP1 ; a * 8 + a * 2 = a * 10
00:C493 8502            	   185:     sta TMP1
                        	   186:     
00:C495 A503            	   187:     lda TMP2
00:C497 38              	   188:     sec
00:C498 E502            	   189:     sbc TMP1 ; a - ((a / 10) * 10) = a % 10
                        	   190:     
00:C49A 60              	   191:     rts
                        	   192: 
                        	   193: 
                        	   194: 
                        	   195: ; -- Prints an 16-byte address as an hexidecimal string to screen (including a space and parentheses)
                        	   196: ; y contains the low byte of the address
                        	   197: ; x contains the high byte of the address
                        	   198: ; BAD_VALUE contains value that was read from RAM but was not equal to what was stored into RAM
                        	   199: ;
                        	   200: print_fixed_ram_address:
                        	   201: 
00:C49B 20D8C3          	   202:     jsr setup_cursor
                        	   203:     
00:C49E A920            	   204:     lda #' '
00:C4A0 8D239F          	   205:     sta VERA_DATA0
00:C4A3 A508            	   206:     lda TEXT_COLOR
00:C4A5 8D239F          	   207:     sta VERA_DATA0
00:C4A8 E609            	   208:     inc CURSOR_X
                        	   209:     
00:C4AA A928            	   210:     lda #'('
00:C4AC 8D239F          	   211:     sta VERA_DATA0
00:C4AF A508            	   212:     lda TEXT_COLOR
00:C4B1 8D239F          	   213:     sta VERA_DATA0
00:C4B4 E609            	   214:     inc CURSOR_X
                        	   215:     
00:C4B6 A924            	   216:     lda #'$'
00:C4B8 8D239F          	   217:     sta VERA_DATA0
00:C4BB A508            	   218:     lda TEXT_COLOR
00:C4BD 8D239F          	   219:     sta VERA_DATA0
00:C4C0 E609            	   220:     inc CURSOR_X
                        	   221:     
00:C4C2 860C            	   222:     stx BYTE_TO_PRINT
00:C4C4 2079C6          	   223:     jsr print_byte_as_hex
00:C4C7 840C            	   224:     sty BYTE_TO_PRINT
00:C4C9 2079C6          	   225:     jsr print_byte_as_hex
                        	   226: 
00:C4CC A93D            	   227:     lda #'='
00:C4CE 8D239F          	   228:     sta VERA_DATA0
00:C4D1 A508            	   229:     lda TEXT_COLOR
00:C4D3 8D239F          	   230:     sta VERA_DATA0
00:C4D6 E609            	   231:     inc CURSOR_X
                        	   232:     
00:C4D8 A924            	   233:     lda #'$'
00:C4DA 8D239F          	   234:     sta VERA_DATA0
00:C4DD A508            	   235:     lda TEXT_COLOR
00:C4DF 8D239F          	   236:     sta VERA_DATA0
00:C4E2 E609            	   237:     inc CURSOR_X
                        	   238:     
00:C4E4 A51A            	   239:     lda BAD_VALUE
00:C4E6 850C            	   240:     sta BYTE_TO_PRINT
00:C4E8 2079C6          	   241:     jsr print_byte_as_hex
                        	   242: 
00:C4EB A929            	   243:     lda #')'
00:C4ED 8D239F          	   244:     sta VERA_DATA0
00:C4F0 A508            	   245:     lda TEXT_COLOR
00:C4F2 8D239F          	   246:     sta VERA_DATA0           
00:C4F5 E609            	   247:     inc CURSOR_X
                        	   248: 
00:C4F7 60              	   249:     rts
                        	   250:     
                        	   251: ; -- Prints an 16-byte address as an hexidecimal string to screen (including a space and parentheses)
                        	   252: ; y contains the low byte of the address
                        	   253: ; x contains the high byte of the address
                        	   254: ; BAD_VALUE contains value that was read from RAM but was not equal to what was stored into RAM
                        	   255: ; 
                        	   256: print_banked_address:
                        	   257: 
00:C4F8 20D8C3          	   258:     jsr setup_cursor
                        	   259:     
00:C4FB A920            	   260:     lda #' '
00:C4FD 8D239F          	   261:     sta VERA_DATA0
00:C500 A508            	   262:     lda TEXT_COLOR
00:C502 8D239F          	   263:     sta VERA_DATA0
00:C505 E609            	   264:     inc CURSOR_X
                        	   265:     
00:C507 A928            	   266:     lda #'('
00:C509 8D239F          	   267:     sta VERA_DATA0
00:C50C A508            	   268:     lda TEXT_COLOR
00:C50E 8D239F          	   269:     sta VERA_DATA0
00:C511 E609            	   270:     inc CURSOR_X
                        	   271:     
00:C513 A512            	   272:     lda BANK_TESTING
00:C515 2025C4          	   273:     jsr print_byte_as_decimal
                        	   274:     
00:C518 A93A            	   275:     lda #':'
00:C51A 8D239F          	   276:     sta VERA_DATA0
00:C51D A508            	   277:     lda TEXT_COLOR
00:C51F 8D239F          	   278:     sta VERA_DATA0
00:C522 E609            	   279:     inc CURSOR_X
                        	   280:     
00:C524 A924            	   281:     lda #'$'
00:C526 8D239F          	   282:     sta VERA_DATA0
00:C529 A508            	   283:     lda TEXT_COLOR
00:C52B 8D239F          	   284:     sta VERA_DATA0
00:C52E E609            	   285:     inc CURSOR_X
                        	   286:     
00:C530 860C            	   287:     stx BYTE_TO_PRINT
00:C532 2079C6          	   288:     jsr print_byte_as_hex
00:C535 840C            	   289:     sty BYTE_TO_PRINT
00:C537 2079C6          	   290:     jsr print_byte_as_hex
                        	   291: 
00:C53A A93D            	   292:     lda #'='
00:C53C 8D239F          	   293:     sta VERA_DATA0
00:C53F A508            	   294:     lda TEXT_COLOR
00:C541 8D239F          	   295:     sta VERA_DATA0
00:C544 E609            	   296:     inc CURSOR_X
                        	   297:     
00:C546 A924            	   298:     lda #'$'
00:C548 8D239F          	   299:     sta VERA_DATA0
00:C54B A508            	   300:     lda TEXT_COLOR
00:C54D 8D239F          	   301:     sta VERA_DATA0
00:C550 E609            	   302:     inc CURSOR_X
                        	   303:     
00:C552 A51A            	   304:     lda BAD_VALUE
00:C554 850C            	   305:     sta BYTE_TO_PRINT
00:C556 2079C6          	   306:     jsr print_byte_as_hex
                        	   307: 
00:C559 A929            	   308:     lda #')'
00:C55B 8D239F          	   309:     sta VERA_DATA0
00:C55E A508            	   310:     lda TEXT_COLOR
00:C560 8D239F          	   311:     sta VERA_DATA0           
00:C563 E609            	   312:     inc CURSOR_X
                        	   313: 
00:C565 60              	   314:     rts
                        	   315:     
                        	   316: 
                        	   317: 
                        	   318: ; -- Prints an 16-byte address as an hexidecimal string to screen (including a space and parentheses)
                        	   319: ; y contains the low byte of the address
                        	   320: ; x contains the high byte of the address
                        	   321: ; BAD_VALUE contains value that was read from RAM but was not equal to what was stored into RAM
                        	   322: ; 
                        	   323: print_lower_vram_address:
                        	   324: 
00:C566 20D8C3          	   325:     jsr setup_cursor
                        	   326:     
00:C569 A920            	   327:     lda #' '
00:C56B 8D239F          	   328:     sta VERA_DATA0
00:C56E A508            	   329:     lda TEXT_COLOR
00:C570 8D239F          	   330:     sta VERA_DATA0
00:C573 E609            	   331:     inc CURSOR_X
                        	   332:     
00:C575 A928            	   333:     lda #'('
00:C577 8D239F          	   334:     sta VERA_DATA0
00:C57A A508            	   335:     lda TEXT_COLOR
00:C57C 8D239F          	   336:     sta VERA_DATA0
00:C57F E609            	   337:     inc CURSOR_X
                        	   338:     
00:C581 A924            	   339:     lda #'$'
00:C583 8D239F          	   340:     sta VERA_DATA0
00:C586 A508            	   341:     lda TEXT_COLOR
00:C588 8D239F          	   342:     sta VERA_DATA0
00:C58B E609            	   343:     inc CURSOR_X
                        	   344: 
                        	   345:     ; Since this is the lower part of vram, we first print a 0 here
00:C58D A930            	   346:     lda #'0'
00:C58F 8D239F          	   347:     sta VERA_DATA0
00:C592 A508            	   348:     lda TEXT_COLOR
00:C594 8D239F          	   349:     sta VERA_DATA0
00:C597 E609            	   350:     inc CURSOR_X
                        	   351:     
00:C599 860C            	   352:     stx BYTE_TO_PRINT
00:C59B 2079C6          	   353:     jsr print_byte_as_hex
00:C59E 840C            	   354:     sty BYTE_TO_PRINT
00:C5A0 2079C6          	   355:     jsr print_byte_as_hex
                        	   356: 
00:C5A3 A93D            	   357:     lda #'='
00:C5A5 8D239F          	   358:     sta VERA_DATA0
00:C5A8 A508            	   359:     lda TEXT_COLOR
00:C5AA 8D239F          	   360:     sta VERA_DATA0
00:C5AD E609            	   361:     inc CURSOR_X
                        	   362:     
00:C5AF A924            	   363:     lda #'$'
00:C5B1 8D239F          	   364:     sta VERA_DATA0
00:C5B4 A508            	   365:     lda TEXT_COLOR
00:C5B6 8D239F          	   366:     sta VERA_DATA0
00:C5B9 E609            	   367:     inc CURSOR_X
                        	   368:     
00:C5BB A51A            	   369:     lda BAD_VALUE
00:C5BD 850C            	   370:     sta BYTE_TO_PRINT
00:C5BF 2079C6          	   371:     jsr print_byte_as_hex
                        	   372: 
00:C5C2 A929            	   373:     lda #')'
00:C5C4 8D239F          	   374:     sta VERA_DATA0
00:C5C7 A508            	   375:     lda TEXT_COLOR
00:C5C9 8D239F          	   376:     sta VERA_DATA0           
00:C5CC E609            	   377:     inc CURSOR_X
                        	   378: 
00:C5CE 60              	   379:     rts
                        	   380: 
                        	   381: ; -- Prints an 16-byte address as an hexidecimal string to screen (including a space and parentheses)
                        	   382: ; y contains the low byte of the address
                        	   383: ; x contains the high byte of the address
                        	   384: ; BAD_VALUE contains value that was read from RAM but was not equal to what was stored into RAM
                        	   385: ; 
                        	   386: print_upper_vram_address:
                        	   387: 
00:C5CF 20D8C3          	   388:     jsr setup_cursor
                        	   389:     
00:C5D2 A920            	   390:     lda #' '
00:C5D4 8D239F          	   391:     sta VERA_DATA0
00:C5D7 A508            	   392:     lda TEXT_COLOR
00:C5D9 8D239F          	   393:     sta VERA_DATA0
00:C5DC E609            	   394:     inc CURSOR_X
                        	   395:     
00:C5DE A928            	   396:     lda #'('
00:C5E0 8D239F          	   397:     sta VERA_DATA0
00:C5E3 A508            	   398:     lda TEXT_COLOR
00:C5E5 8D239F          	   399:     sta VERA_DATA0
00:C5E8 E609            	   400:     inc CURSOR_X
                        	   401:     
00:C5EA A924            	   402:     lda #'$'
00:C5EC 8D239F          	   403:     sta VERA_DATA0
00:C5EF A508            	   404:     lda TEXT_COLOR
00:C5F1 8D239F          	   405:     sta VERA_DATA0
00:C5F4 E609            	   406:     inc CURSOR_X
                        	   407: 
                        	   408:     ; Since this is the upper part of vram, we first print a 1 here
00:C5F6 A931            	   409:     lda #'1'
00:C5F8 8D239F          	   410:     sta VERA_DATA0
00:C5FB A508            	   411:     lda TEXT_COLOR
00:C5FD 8D239F          	   412:     sta VERA_DATA0
00:C600 E609            	   413:     inc CURSOR_X
                        	   414:     
00:C602 860C            	   415:     stx BYTE_TO_PRINT
00:C604 2079C6          	   416:     jsr print_byte_as_hex
00:C607 840C            	   417:     sty BYTE_TO_PRINT
00:C609 2079C6          	   418:     jsr print_byte_as_hex
                        	   419: 
00:C60C A93D            	   420:     lda #'='
00:C60E 8D239F          	   421:     sta VERA_DATA0
00:C611 A508            	   422:     lda TEXT_COLOR
00:C613 8D239F          	   423:     sta VERA_DATA0
00:C616 E609            	   424:     inc CURSOR_X
                        	   425:     
00:C618 A924            	   426:     lda #'$'
00:C61A 8D239F          	   427:     sta VERA_DATA0
00:C61D A508            	   428:     lda TEXT_COLOR
00:C61F 8D239F          	   429:     sta VERA_DATA0
00:C622 E609            	   430:     inc CURSOR_X
                        	   431:     
00:C624 A51A            	   432:     lda BAD_VALUE
00:C626 850C            	   433:     sta BYTE_TO_PRINT
00:C628 2079C6          	   434:     jsr print_byte_as_hex
                        	   435: 
00:C62B A929            	   436:     lda #')'
00:C62D 8D239F          	   437:     sta VERA_DATA0
00:C630 A508            	   438:     lda TEXT_COLOR
00:C632 8D239F          	   439:     sta VERA_DATA0           
00:C635 E609            	   440:     inc CURSOR_X
                        	   441: 
00:C637 60              	   442:     rts
                        	   443: 
                        	   444: ; x = command number (to print as decimal)
                        	   445: ; a = error byte to print in hex
                        	   446: print_spi_cmd_error:
00:C638 48              	   447:     pha
00:C639 8A              	   448:     txa
00:C63A 48              	   449:     pha
                        	   450:     
00:C63B A942            	   451:     lda #COLOR_ERROR
00:C63D 8508            	   452:     sta TEXT_COLOR
                        	   453:     
00:C63F A9C3            	   454:     lda #<spi_command_error
00:C641 8506            	   455:     sta TEXT_TO_PRINT
00:C643 A9C3            	   456:     lda #>spi_command_error
00:C645 8507            	   457:     sta TEXT_TO_PRINT + 1
                        	   458:     
00:C647 20ECC3          	   459:     jsr print_text_zero
                        	   460:     
00:C64A 68              	   461:     pla ; contains command number
00:C64B 2025C4          	   462:     jsr print_byte_as_decimal
                        	   463: 
00:C64E A93A            	   464:     lda #':'
00:C650 8D239F          	   465:     sta VERA_DATA0
00:C653 A508            	   466:     lda TEXT_COLOR
00:C655 8D239F          	   467:     sta VERA_DATA0
00:C658 E609            	   468:     inc CURSOR_X
                        	   469:     
00:C65A A924            	   470:     lda #'$'
00:C65C 8D239F          	   471:     sta VERA_DATA0
00:C65F A508            	   472:     lda TEXT_COLOR
00:C661 8D239F          	   473:     sta VERA_DATA0
00:C664 E609            	   474:     inc CURSOR_X
                        	   475:     
                        	   476:     ; FIXME: for now we are simply printing the value we received from the SD card
                        	   477:     ; if the value is #$01 we should say 'OK', otherwise we should print the byte as error
00:C666 68              	   478:     pla
00:C667 850C            	   479:     sta BYTE_TO_PRINT
00:C669 2079C6          	   480:     jsr print_byte_as_hex
                        	   481: 
00:C66C A929            	   482:     lda #')'
00:C66E 8D239F          	   483:     sta VERA_DATA0
00:C671 A508            	   484:     lda TEXT_COLOR
00:C673 8D239F          	   485:     sta VERA_DATA0
00:C676 E609            	   486:     inc CURSOR_X
                        	   487:     
00:C678 60              	   488:     rts
                        	   489:     
                        	   490: 
                        	   491: ; BYTE_TO_PRINT : contains the byte to print as hex
                        	   492: print_byte_as_hex:
                        	   493:     
                        	   494:     ; Print high nibble
00:C679 A50C            	   495:     lda BYTE_TO_PRINT
00:C67B 4A              	   496:     lsr
00:C67C 4A              	   497:     lsr
00:C67D 4A              	   498:     lsr
00:C67E 4A              	   499:     lsr
00:C67F C90A            	   500:     cmp #10
00:C681 1006            	   501:     bpl high_nibble_is_larger_than_or_equal_to_10
00:C683 18              	   502:     clc
00:C684 6930            	   503:     adc #'0'
00:C686 4C8CC6          	   504:     jmp high_nibble_ready
                        	   505: high_nibble_is_larger_than_or_equal_to_10:
00:C689 38              	   506:     sec
00:C68A E909            	   507:     sbc #9
                        	   508: high_nibble_ready:
00:C68C 8D239F          	   509:     sta VERA_DATA0
00:C68F A508            	   510:     lda TEXT_COLOR
00:C691 8D239F          	   511:     sta VERA_DATA0
00:C694 E609            	   512:     inc CURSOR_X
                        	   513:     
                        	   514:     ; Print low nibble
00:C696 A50C            	   515:     lda BYTE_TO_PRINT
00:C698 290F            	   516:     and #$0f
00:C69A C90A            	   517:     cmp #10
00:C69C 1006            	   518:     bpl low_nibble_is_larger_than_or_equal_to_10
00:C69E 18              	   519:     clc
00:C69F 6930            	   520:     adc #'0'
00:C6A1 4CA7C6          	   521:     jmp low_nibble_ready
                        	   522: low_nibble_is_larger_than_or_equal_to_10:
00:C6A4 38              	   523:     sec
00:C6A5 E909            	   524:     sbc #9
                        	   525: low_nibble_ready:
00:C6A7 8D239F          	   526:     sta VERA_DATA0
00:C6AA A508            	   527:     lda TEXT_COLOR
00:C6AC 8D239F          	   528:     sta VERA_DATA0
00:C6AF E609            	   529:     inc CURSOR_X
                        	   530:     
00:C6B1 60              	   531:     rts
                        	   532:     
                        	   533: 
                        	   534:     
                        	   535:     
                        	   536:     ; --- Testing a range of RAM (one block of 256 bytes at a time)
                        	   537: test_ram_block:
                        	   538: 
00:C6B2 A900            	   539:     lda #0
00:C6B4 8514            	   540:     sta MEMORY_ADDR_TESTING
00:C6B6 A610            	   541:     ldx START_ADDR_HIGH
                        	   542:     
                        	   543: check_next_ram_block:
00:C6B8 8615            	   544:     stx MEMORY_ADDR_TESTING+1
                        	   545:     
00:C6BA A000            	   546:     ldy #0
                        	   547: check_ram_block_FF:
00:C6BC A9FF            	   548:     lda #$FF
00:C6BE 9114            	   549:     sta (MEMORY_ADDR_TESTING), y
00:C6C0 B114            	   550:     lda (MEMORY_ADDR_TESTING), y
00:C6C2 C9FF            	   551:     cmp #$FF
00:C6C4 D01B            	   552:     bne ram_is_not_ok
00:C6C6 C8              	   553:     iny
00:C6C7 D0F3            	   554:     bne check_ram_block_FF
                        	   555:     
00:C6C9 A000            	   556:     ldy #0
                        	   557: check_ram_block_00:
00:C6CB A900            	   558:     lda #$00
00:C6CD 9114            	   559:     sta (MEMORY_ADDR_TESTING), y
00:C6CF B114            	   560:     lda (MEMORY_ADDR_TESTING), y
00:C6D1 C900            	   561:     cmp #$00
00:C6D3 D00C            	   562:     bne ram_is_not_ok
00:C6D5 C8              	   563:     iny
00:C6D6 D0F3            	   564:     bne check_ram_block_00
                        	   565:     
00:C6D8 E8              	   566:     inx
00:C6D9 E411            	   567:     cpx END_ADDR_HIGH
00:C6DB D0DB            	   568:     bne check_next_ram_block
                        	   569:     
00:C6DD 38              	   570:     sec   ; We set the carry flag: 'ok'
00:C6DE 4CE5C6          	   571:     jmp done_testing_ram
                        	   572: ram_is_not_ok:
                        	   573:     ; Currently used to trigger an LA
00:C6E1 8D609F          	   574:     sta IO3_BASE_ADDRESS
                        	   575:     
00:C6E4 18              	   576:     clc    ; We clear the carry flag: 'not ok'
                        	   577: done_testing_ram:
00:C6E5 60              	   578:     rts

Source: "x16_hardware_tester.s"
                        	   142:     .include tests/fixed_ram_tests.s

Source: "tests\fixed_ram_tests.s"
                        	     1: 
                        	     2: ; Note: these start and end addresses need to end with 00
                        	     3: FIXED_RAM_START_ADDR = $0200
                        	     4: FIXED_RAM_END_ADDR   = $9F00
                        	     5: 
                        	     6: fixed_ram_header_message: 
00:C6E6 4669786564205241	     7:     .asciiz "Fixed RAM:"
00:C6EE 4D3A
00:C6F0 00
                        	     8: testing_fixed_ram_message: 
00:C6F1 54657374696E6720	     9:     .asciiz "Testing Fixed RAM ($0200 - $9EFF) ... "
00:C6F9 4669786564205241
00:C701 4D20282430323030
00:C709 202D202439454646
00:C711 29202E2E2E20
00:C717 00
                        	    10: 
                        	    11: ; --- Testing Fixed RAM
                        	    12: test_fixed_ram:
                        	    13: 
00:C718 A941            	    14:     lda #COLOR_NORMAL
00:C71A 8508            	    15:     sta TEXT_COLOR
                        	    16:     
00:C71C A9F1            	    17:     lda #<testing_fixed_ram_message
00:C71E 8506            	    18:     sta TEXT_TO_PRINT
00:C720 A9C6            	    19:     lda #>testing_fixed_ram_message
00:C722 8507            	    20:     sta TEXT_TO_PRINT + 1
                        	    21:     
00:C724 20ECC3          	    22:     jsr print_text_zero
                        	    23:     
                        	    24:     ; Setting up setup the range to check
00:C727 A902            	    25:     lda #>FIXED_RAM_START_ADDR
00:C729 8510            	    26:     sta START_ADDR_HIGH
00:C72B A99F            	    27:     lda #>FIXED_RAM_END_ADDR
00:C72D 8511            	    28:     sta END_ADDR_HIGH
                        	    29:     
00:C72F 20B2C6          	    30:     jsr test_ram_block
                        	    31:     
00:C732 9012            	    32:     bcc fixed_ram_is_not_ok
                        	    33: 
                        	    34: fixed_ram_is_ok:
00:C734 A945            	    35:     lda #COLOR_OK
00:C736 8508            	    36:     sta TEXT_COLOR
                        	    37:     
00:C738 A9B9            	    38:     lda #<ok_message
00:C73A 8506            	    39:     sta TEXT_TO_PRINT
00:C73C A9C3            	    40:     lda #>ok_message
00:C73E 8507            	    41:     sta TEXT_TO_PRINT + 1
                        	    42:     
00:C740 20ECC3          	    43:     jsr print_text_zero
00:C743 4C5AC7          	    44:     jmp done_testing_fixed_ram
                        	    45:     
                        	    46: fixed_ram_is_not_ok:
                        	    47:     ; We preserve the bad value into a ZP register
00:C746 851A            	    48:     sta BAD_VALUE
                        	    49: 
00:C748 A942            	    50:     lda #COLOR_ERROR
00:C74A 8508            	    51:     sta TEXT_COLOR
                        	    52:     
00:C74C A9BC            	    53:     lda #<not_ok_message
00:C74E 8506            	    54:     sta TEXT_TO_PRINT
00:C750 A9C3            	    55:     lda #>not_ok_message
00:C752 8507            	    56:     sta TEXT_TO_PRINT + 1
                        	    57:     
00:C754 20ECC3          	    58:     jsr print_text_zero
                        	    59: 
                        	    60:     ; This uses x as high byte and y as low byte of the address to print    
00:C757 209BC4          	    61:     jsr print_fixed_ram_address
                        	    62:     
                        	    63: done_testing_fixed_ram:
00:C75A 20CFC3          	    64:     jsr move_cursor_to_next_line
                        	    65: 
00:C75D 60              	    66:     rts
                        	    67:     

Source: "x16_hardware_tester.s"
                        	   143:     .include tests/banked_ram_tests.s

Source: "tests\banked_ram_tests.s"
                        	     1: 
                        	     2: ; Note: these start and end addresses need to end with 00
                        	     3: BANKED_RAM_START_ADDR = $A000
                        	     4: BANKED_RAM_END_ADDR   = $C000
                        	     5: 
                        	     6: banked_ram_header: 
00:C75E 42616E6B65642052	     7:     .asciiz "Banked RAM:"
00:C766 414D3A
00:C769 00
                        	     8: testing_banked_ram_message1: 
00:C76A 54657374696E6720	     9:     .asciiz "Testing "
00:C772 00
                        	    10: testing_banked_ram_message2: 
00:C773 20756E6971756520	    11:     .asciiz " unique RAM Banks ($A000 - $BFFF) ... "
00:C77B 52414D2042616E6B
00:C783 7320282441303030
00:C78B 202D202442464646
00:C793 29202E2E2E20
00:C799 00
                        	    12: nr_of_working_ram_banks_message: 
00:C79A 4D6561737572696E	    13:     .asciiz "Measuring number of working RAM banks ... "
00:C7A2 67206E756D626572
00:C7AA 206F6620776F726B
00:C7B2 696E672052414D20
00:C7BA 62616E6B73202E2E
00:C7C2 2E20
00:C7C4 00
                        	    14: nr_of_unique_ram_banks_message: 
00:C7C5 4D6561737572696E	    15:     .asciiz "Measuring number of unique RAM banks ... "
00:C7CD 67206E756D626572
00:C7D5 206F6620756E6971
00:C7DD 75652052414D2062
00:C7E5 616E6B73202E2E2E
00:C7ED 20
00:C7EE 00
                        	    16: nr_of_ram_banks_256_message: 
00:C7EF 323536          	    17:     .asciiz "256"
00:C7F2 00
                        	    18: 
                        	    19: print_banked_ram_header:
00:C7F3 A902            	    20:     lda #MARGIN
00:C7F5 850B            	    21:     sta INDENTATION
00:C7F7 8509            	    22:     sta CURSOR_X
                        	    23:     
00:C7F9 A60A            	    24:     ldx CURSOR_Y
00:C7FB E8              	    25:     inx
00:C7FC 860A            	    26:     stx CURSOR_Y
                        	    27:     
00:C7FE A947            	    28:     lda #COLOR_HEADER
00:C800 8508            	    29:     sta TEXT_COLOR
00:C802 A95E            	    30:     lda #<banked_ram_header
00:C804 8506            	    31:     sta TEXT_TO_PRINT
00:C806 A9C7            	    32:     lda #>banked_ram_header
00:C808 8507            	    33:     sta TEXT_TO_PRINT + 1
                        	    34: 
00:C80A 20ECC3          	    35:     jsr print_text_zero
                        	    36:     
00:C80D A904            	    37:     lda #(MARGIN+INDENT_SIZE)
00:C80F 850B            	    38:     sta INDENTATION
                        	    39:     
00:C811 20CFC3          	    40:     jsr move_cursor_to_next_line
                        	    41:     
00:C814 60              	    42:     rts
                        	    43:     
                        	    44:     
                        	    45:     ; --- Testing Banked RAM
                        	    46: test_banked_ram:
                        	    47: 
00:C815 A941            	    48:     lda #COLOR_NORMAL
00:C817 8508            	    49:     sta TEXT_COLOR
                        	    50:     
00:C819 A96A            	    51:     lda #<testing_banked_ram_message1
00:C81B 8506            	    52:     sta TEXT_TO_PRINT
00:C81D A9C7            	    53:     lda #>testing_banked_ram_message1
00:C81F 8507            	    54:     sta TEXT_TO_PRINT + 1
                        	    55:     
00:C821 20ECC3          	    56:     jsr print_text_zero
                        	    57:     
00:C824 A519            	    58:     lda NR_OF_UNIQUE_RAM_BANKS+1
00:C826 D008            	    59:     bne print_256_unique_while_testing 
                        	    60:     
                        	    61:     ; Less than 256 unqiue banks
00:C828 A518            	    62:     lda NR_OF_UNIQUE_RAM_BANKS
00:C82A 2025C4          	    63:     jsr print_byte_as_decimal
                        	    64:     
00:C82D 4C3BC8          	    65:     jmp done_printing_nr_of_banked_ram
                        	    66: print_256_unique_while_testing:
                        	    67:     ; Exactly 256 unqiue banks
00:C830 A9EF            	    68:     lda #<nr_of_ram_banks_256_message
00:C832 8506            	    69:     sta TEXT_TO_PRINT
00:C834 A9C7            	    70:     lda #>nr_of_ram_banks_256_message
00:C836 8507            	    71:     sta TEXT_TO_PRINT + 1
00:C838 20ECC3          	    72:     jsr print_text_zero
                        	    73:     
                        	    74: done_printing_nr_of_banked_ram:    
00:C83B A973            	    75:     lda #<testing_banked_ram_message2
00:C83D 8506            	    76:     sta TEXT_TO_PRINT
00:C83F A9C7            	    77:     lda #>testing_banked_ram_message2
00:C841 8507            	    78:     sta TEXT_TO_PRINT + 1
                        	    79:     
00:C843 20ECC3          	    80:     jsr print_text_zero
                        	    81:     
00:C846 A900            	    82:     lda #0
00:C848 8512            	    83:     sta BANK_TESTING
                        	    84:     
                        	    85: next_ram_bank_to_test:
00:C84A A512            	    86:     lda BANK_TESTING
00:C84C 8500            	    87:     sta RAM_BANK
                        	    88:     ; FIXME: remove this nop!
00:C84E EA              	    89:     nop
                        	    90:     
00:C84F A609            	    91:     ldx CURSOR_X
00:C851 8605            	    92:     stx TMP4
00:C853 2025C4          	    93:     jsr print_byte_as_decimal
00:C856 A605            	    94:     ldx TMP4
00:C858 8609            	    95:     stx CURSOR_X
                        	    96:     
                        	    97:     ; Setting up setup the range to check
00:C85A A9A0            	    98:     lda #>BANKED_RAM_START_ADDR
00:C85C 8510            	    99:     sta START_ADDR_HIGH
00:C85E A9C0            	   100:     lda #>BANKED_RAM_END_ADDR
00:C860 8511            	   101:     sta END_ADDR_HIGH
                        	   102:     
00:C862 20B2C6          	   103:     jsr test_ram_block
                        	   104:     
00:C865 9025            	   105:     bcc banked_ram_is_not_ok
                        	   106:     
00:C867 A612            	   107:     ldx BANK_TESTING
00:C869 E8              	   108:     inx
00:C86A 8612            	   109:     stx BANK_TESTING
00:C86C E418            	   110:     cpx NR_OF_UNIQUE_RAM_BANKS
00:C86E D0DA            	   111:     bne next_ram_bank_to_test
                        	   112:     
                        	   113: banked_ram_is_ok:
00:C870 A945            	   114:     lda #COLOR_OK
00:C872 8508            	   115:     sta TEXT_COLOR
                        	   116:     
00:C874 A9B9            	   117:     lda #<ok_message
00:C876 8506            	   118:     sta TEXT_TO_PRINT
00:C878 A9C3            	   119:     lda #>ok_message
00:C87A 8507            	   120:     sta TEXT_TO_PRINT + 1
                        	   121:     
00:C87C 20ECC3          	   122:     jsr print_text_zero
                        	   123:     
                        	   124:     ; TODO: this is a dirty workaround to overwrite the 3-digit counter that is not covered by the 2-letter word 'ok'
00:C87F A920            	   125:     lda #' '
00:C881 8D239F          	   126:     sta VERA_DATA0
00:C884 A508            	   127:     lda TEXT_COLOR
00:C886 8D239F          	   128:     sta VERA_DATA0           
                        	   129:     
00:C889 4CA0C8          	   130:     jmp done_testing_banked_ram
                        	   131:     
                        	   132: banked_ram_is_not_ok:
                        	   133:     ; We preserve the bad value into a ZP register
00:C88C 851A            	   134:     sta BAD_VALUE
                        	   135: 
00:C88E A942            	   136:     lda #COLOR_ERROR
00:C890 8508            	   137:     sta TEXT_COLOR
                        	   138:     
00:C892 A9BC            	   139:     lda #<not_ok_message
00:C894 8506            	   140:     sta TEXT_TO_PRINT
00:C896 A9C3            	   141:     lda #>not_ok_message
00:C898 8507            	   142:     sta TEXT_TO_PRINT + 1
                        	   143:     
00:C89A 20ECC3          	   144:     jsr print_text_zero
                        	   145: 
                        	   146:     ; This uses x as high byte and y as low byte of the address to print    
00:C89D 20F8C4          	   147:     jsr print_banked_address
                        	   148:     
                        	   149: done_testing_banked_ram:
00:C8A0 20CFC3          	   150:     jsr move_cursor_to_next_line
                        	   151: 
00:C8A3 60              	   152:     rts
                        	   153:     
                        	   154:     
                        	   155:     
                        	   156:     
                        	   157:     ; -- Determine amount of Banked RAM
                        	   158:     
                        	   159: determine_nr_of_ram_banks:
                        	   160: 
00:C8A4 A900            	   161:     lda #0
00:C8A6 8516            	   162:     sta NR_OF_WORKING_RAM_BANKS
00:C8A8 8517            	   163:     sta NR_OF_WORKING_RAM_BANKS+1
00:C8AA 8518            	   164:     sta NR_OF_UNIQUE_RAM_BANKS
00:C8AC 8519            	   165:     sta NR_OF_UNIQUE_RAM_BANKS+1
                        	   166:     
                        	   167:     ; - First we set the first byte of each byte to 00 (and check if its working at all)
                        	   168:     
00:C8AE A200            	   169:     ldx #0 ; We start with bank 0
                        	   170: check_for_working_next_ram_bank:
00:C8B0 8600            	   171:     stx RAM_BANK                 ; Switching to the RAM bank
                        	   172: ; FIXME: we should remove this nop!!
00:C8B2 EA              	   173:     nop
                        	   174:     
00:C8B3 A9FF            	   175:     lda #$FF
00:C8B5 8D00A0          	   176:     sta BANKED_RAM_START_ADDR
00:C8B8 AD00A0          	   177:     lda BANKED_RAM_START_ADDR
00:C8BB C9FF            	   178:     cmp #$FF
00:C8BD D016            	   179:     bne bank_is_not_working
00:C8BF A900            	   180:     lda #$00
00:C8C1 8D00A0          	   181:     sta BANKED_RAM_START_ADDR
00:C8C4 AD00A0          	   182:     lda BANKED_RAM_START_ADDR
00:C8C7 C900            	   183:     cmp #$00
00:C8C9 D00A            	   184:     bne bank_is_not_working
00:C8CB E8              	   185:     inx
00:C8CC D0E2            	   186:     bne check_for_working_next_ram_bank
                        	   187:     
                        	   188:     ; All 256 banks are working
00:C8CE A901            	   189:     lda #1
00:C8D0 8517            	   190:     sta NR_OF_WORKING_RAM_BANKS+1   ; Storing the value $0100
                        	   191:     
00:C8D2 4CDBC8          	   192:     jmp start_unique_ram_check
                        	   193: 
                        	   194: bank_is_not_working:
00:C8D5 8616            	   195:     stx NR_OF_WORKING_RAM_BANKS
00:C8D7 E000            	   196:     cpx #0   ; If we found no working banks at all, we should not check the number of unique banks
00:C8D9 F021            	   197:     beq done_nr_of_banks
                        	   198: 
                        	   199: start_unique_ram_check:
                        	   200:     ; - Then we read each first byte and (if still 0) we store an incrementing number in it
00:C8DB A200            	   201:     ldx #0 ; We start with bank 0
                        	   202: check_next_ram_bank:
00:C8DD 8600            	   203:     stx RAM_BANK                 ; Switching to the RAM bank
                        	   204: ; FIXME: we should remove this nop!!
00:C8DF EA              	   205:     nop
                        	   206:     
00:C8E0 AD00A0          	   207:     lda BANKED_RAM_START_ADDR  ; We read the current value (0 if not yet touched)
00:C8E3 D015            	   208:     bne bank_already_counted   ; If not 0, the memory is looping/reused
00:C8E5 A92A            	   209:     lda #42
00:C8E7 8D00A0          	   210:     sta BANKED_RAM_START_ADDR  ; We store a 'random' number in it
00:C8EA E8              	   211:     inx
00:C8EB E416            	   212:     cpx NR_OF_WORKING_RAM_BANKS  ; Note that if NR_OF_WORKING_RAM_BANKS = $0100, this will check all 256 banks
00:C8ED D0EE            	   213:     bne check_next_ram_bank
                        	   214: 
                        	   215:     ; All working banks are unique
00:C8EF A517            	   216:     lda NR_OF_WORKING_RAM_BANKS+1
00:C8F1 8519            	   217:     sta NR_OF_UNIQUE_RAM_BANKS+1
00:C8F3 A516            	   218:     lda NR_OF_WORKING_RAM_BANKS
00:C8F5 8518            	   219:     sta NR_OF_UNIQUE_RAM_BANKS
00:C8F7 4CFCC8          	   220:     jmp done_nr_of_banks
                        	   221:     
                        	   222: bank_already_counted:
00:C8FA 8618            	   223:     stx NR_OF_UNIQUE_RAM_BANKS
                        	   224: 
                        	   225: done_nr_of_banks:
                        	   226:     
00:C8FC A941            	   227:     lda #COLOR_NORMAL
00:C8FE 8508            	   228:     sta TEXT_COLOR
                        	   229:     
00:C900 A99A            	   230:     lda #<nr_of_working_ram_banks_message
00:C902 8506            	   231:     sta TEXT_TO_PRINT
00:C904 A9C7            	   232:     lda #>nr_of_working_ram_banks_message
00:C906 8507            	   233:     sta TEXT_TO_PRINT + 1
00:C908 20ECC3          	   234:     jsr print_text_zero
                        	   235: 
                        	   236:     ; Print byte as decimal (and if 256, print '256')
                        	   237:     
00:C90B A517            	   238:     lda NR_OF_WORKING_RAM_BANKS+1
00:C90D D00C            	   239:     bne print_256_working
                        	   240:     
                        	   241:     ; Giving a 'WARNING/ERROR' is not all 256 ram banks are working
                        	   242:     
00:C90F A942            	   243:     lda #COLOR_ERROR
00:C911 8508            	   244:     sta TEXT_COLOR
                        	   245:     
00:C913 A516            	   246:     lda NR_OF_WORKING_RAM_BANKS
00:C915 2025C4          	   247:     jsr print_byte_as_decimal
                        	   248:     
00:C918 4C2AC9          	   249:     jmp done_printing_working_banks
                        	   250:     
                        	   251: print_256_working:    
00:C91B A945            	   252:     lda #COLOR_OK
00:C91D 8508            	   253:     sta TEXT_COLOR
                        	   254:     
00:C91F A9EF            	   255:     lda #<nr_of_ram_banks_256_message
00:C921 8506            	   256:     sta TEXT_TO_PRINT
00:C923 A9C7            	   257:     lda #>nr_of_ram_banks_256_message
00:C925 8507            	   258:     sta TEXT_TO_PRINT + 1
00:C927 20ECC3          	   259:     jsr print_text_zero
                        	   260: 
                        	   261: done_printing_working_banks:
00:C92A A941            	   262:     lda #COLOR_NORMAL
00:C92C 8508            	   263:     sta TEXT_COLOR
                        	   264:     
00:C92E 20CFC3          	   265:     jsr move_cursor_to_next_line
                        	   266:     
00:C931 A9C5            	   267:     lda #<nr_of_unique_ram_banks_message
00:C933 8506            	   268:     sta TEXT_TO_PRINT
00:C935 A9C7            	   269:     lda #>nr_of_unique_ram_banks_message
00:C937 8507            	   270:     sta TEXT_TO_PRINT + 1
00:C939 20ECC3          	   271:     jsr print_text_zero
                        	   272:     
00:C93C A519            	   273:     lda NR_OF_UNIQUE_RAM_BANKS+1
00:C93E D01D            	   274:     bne print_256_unique
                        	   275:     
                        	   276:     ; Print byte as decimal (and if 256, print '256')
                        	   277: 
00:C940 A518            	   278:     lda NR_OF_UNIQUE_RAM_BANKS
00:C942 C940            	   279:     cmp #64
00:C944 F00B            	   280:     beq print_unique_banks_ok
00:C946 C980            	   281:     cmp #128
00:C948 F007            	   282:     beq print_unique_banks_ok
                        	   283:     
                        	   284:     ; Giving a 'WARNING/ERROR' if you unique bank count is other than 64 or 128 (note that 1 bank means that your bank 
                        	   285: 
                        	   286: print_unique_banks_not_ok:
00:C94A A942            	   287:     lda #COLOR_ERROR
00:C94C 8508            	   288:     sta TEXT_COLOR
00:C94E 4C55C9          	   289:     jmp print_unique_banks
                        	   290: print_unique_banks_ok:
00:C951 A945            	   291:     lda #COLOR_OK
00:C953 8508            	   292:     sta TEXT_COLOR
                        	   293: print_unique_banks:
00:C955 A518            	   294:     lda NR_OF_UNIQUE_RAM_BANKS
00:C957 2025C4          	   295:     jsr print_byte_as_decimal
                        	   296: 
00:C95A 4C6CC9          	   297:     jmp done_printing_unique_banks
                        	   298: 
                        	   299: print_256_unique:
00:C95D A945            	   300:     lda #COLOR_OK
00:C95F 8508            	   301:     sta TEXT_COLOR
                        	   302:     
00:C961 A9EF            	   303:     lda #<nr_of_ram_banks_256_message
00:C963 8506            	   304:     sta TEXT_TO_PRINT
00:C965 A9C7            	   305:     lda #>nr_of_ram_banks_256_message
00:C967 8507            	   306:     sta TEXT_TO_PRINT + 1
00:C969 20ECC3          	   307:     jsr print_text_zero
                        	   308:     
                        	   309:     
                        	   310: done_printing_unique_banks:
00:C96C 20CFC3          	   311:     jsr move_cursor_to_next_line
                        	   312: 
00:C96F 60              	   313:     rts
                        	   314: 
                        	   315: 

Source: "x16_hardware_tester.s"
                        	   144:     .include tests/banked_rom_tests.s

Source: "tests\banked_rom_tests.s"
                        	     1: 
                        	     2: ; Note: these start and end addresses need to end with 00
                        	     3: BANKED_ROM_START_ADDR = $C000
                        	     4: BANKED_ROM_END_ADDR   = $0000
                        	     5: NR_OF_ROM_BANKS       = 32
                        	     6: 
                        	     7: banked_rom_header: 
00:C970 42616E6B65642052	     8:     .asciiz "Banked ROM:"
00:C978 4F4D3A
00:C97B 00
                        	     9: testing_banked_rom_message: 
00:C97C 54657374696E6720	    10:     .asciiz "Testing ROM Banks 1-31 ($C000 - $FFFF) ... "
00:C984 524F4D2042616E6B
00:C98C 7320312D33312028
00:C994 2443303030202D20
00:C99C 244646464629202E
00:C9A4 2E2E20
00:C9A7 00
                        	    11: 
                        	    12:     
                        	    13: print_banked_rom_header:
00:C9A8 A902            	    14:     lda #MARGIN
00:C9AA 850B            	    15:     sta INDENTATION
00:C9AC 8509            	    16:     sta CURSOR_X
                        	    17:     
00:C9AE A60A            	    18:     ldx CURSOR_Y
00:C9B0 E8              	    19:     inx
00:C9B1 860A            	    20:     stx CURSOR_Y
                        	    21:     
00:C9B3 A947            	    22:     lda #COLOR_HEADER
00:C9B5 8508            	    23:     sta TEXT_COLOR
00:C9B7 A970            	    24:     lda #<banked_rom_header
00:C9B9 8506            	    25:     sta TEXT_TO_PRINT
00:C9BB A9C9            	    26:     lda #>banked_rom_header
00:C9BD 8507            	    27:     sta TEXT_TO_PRINT + 1
                        	    28: 
00:C9BF 20ECC3          	    29:     jsr print_text_zero
                        	    30:     
00:C9C2 A904            	    31:     lda #(MARGIN+INDENT_SIZE)
00:C9C4 850B            	    32:     sta INDENTATION
                        	    33:     
00:C9C6 20CFC3          	    34:     jsr move_cursor_to_next_line
                        	    35:     
00:C9C9 60              	    36:     rts
                        	    37:     
                        	    38: 
                        	    39:     ; --- Testing ROM Banks
                        	    40: test_rom_banks:
                        	    41: 
                        	    42:     ; Copying test_rom_bank -> ROM_TEST_CODE
                        	    43:     
00:C9CA A000            	    44:     ldy #0
                        	    45: copy_rom_test_code_byte:
00:C9CC B935CA          	    46:     lda test_rom_bank, y
00:C9CF 990040          	    47:     sta ROM_TEST_CODE, y
00:C9D2 C8              	    48:     iny 
00:C9D3 C02E            	    49:     cpy #(end_of_test_rom_bank-test_rom_bank)
00:C9D5 D0F5            	    50:     bne copy_rom_test_code_byte
                        	    51:     
                        	    52:     ; Printing message
                        	    53: 
00:C9D7 A941            	    54:     lda #COLOR_NORMAL
00:C9D9 8508            	    55:     sta TEXT_COLOR
                        	    56:     
00:C9DB A97C            	    57:     lda #<testing_banked_rom_message
00:C9DD 8506            	    58:     sta TEXT_TO_PRINT
00:C9DF A9C9            	    59:     lda #>testing_banked_rom_message
00:C9E1 8507            	    60:     sta TEXT_TO_PRINT + 1
                        	    61:     
00:C9E3 20ECC3          	    62:     jsr print_text_zero
                        	    63:     
                        	    64:     ; Setting up setup the range to check
                        	    65:     
00:C9E6 A9C0            	    66:     lda #>BANKED_ROM_START_ADDR
00:C9E8 8510            	    67:     sta START_ADDR_HIGH
00:C9EA A900            	    68:     lda #>BANKED_ROM_END_ADDR
00:C9EC 8511            	    69:     sta END_ADDR_HIGH
                        	    70:     
                        	    71:     ; We start at rom bank 1, since rom bank 0 is obviously working (we run this code from it!)
00:C9EE A901            	    72:     lda #1
00:C9F0 8512            	    73:     sta BANK_TESTING
                        	    74:     
                        	    75: next_rom_bank_to_test:
00:C9F2 A609            	    76:     ldx CURSOR_X
00:C9F4 8605            	    77:     stx TMP4
00:C9F6 2025C4          	    78:     jsr print_byte_as_decimal
00:C9F9 A605            	    79:     ldx TMP4
00:C9FB 8609            	    80:     stx CURSOR_X
                        	    81:     
00:C9FD 200040          	    82:     jsr ROM_TEST_CODE
                        	    83:     
00:CA00 901B            	    84:     bcc banked_rom_is_not_ok
                        	    85:     
00:CA02 A612            	    86:     ldx BANK_TESTING
00:CA04 E8              	    87:     inx
00:CA05 8612            	    88:     stx BANK_TESTING
00:CA07 E020            	    89:     cpx #NR_OF_ROM_BANKS
00:CA09 D0E7            	    90:     bne next_rom_bank_to_test
                        	    91:     
                        	    92: banked_rom_is_ok:
00:CA0B A945            	    93:     lda #COLOR_OK
00:CA0D 8508            	    94:     sta TEXT_COLOR
                        	    95:     
00:CA0F A9B9            	    96:     lda #<ok_message
00:CA11 8506            	    97:     sta TEXT_TO_PRINT
00:CA13 A9C3            	    98:     lda #>ok_message
00:CA15 8507            	    99:     sta TEXT_TO_PRINT + 1
                        	   100:     
00:CA17 20ECC3          	   101:     jsr print_text_zero
                        	   102:     
00:CA1A 4C31CA          	   103:     jmp done_testing_banked_rom
                        	   104:     
                        	   105: banked_rom_is_not_ok:
                        	   106:     ; We preserve the bad value into a ZP register
00:CA1D 851A            	   107:     sta BAD_VALUE
                        	   108: 
00:CA1F A942            	   109:     lda #COLOR_ERROR
00:CA21 8508            	   110:     sta TEXT_COLOR
                        	   111:     
00:CA23 A9BC            	   112:     lda #<not_ok_message
00:CA25 8506            	   113:     sta TEXT_TO_PRINT
00:CA27 A9C3            	   114:     lda #>not_ok_message
00:CA29 8507            	   115:     sta TEXT_TO_PRINT + 1
                        	   116:     
00:CA2B 20ECC3          	   117:     jsr print_text_zero
                        	   118: 
                        	   119:     ; This uses x as high byte and y as low byte of the address to print    
00:CA2E 20F8C4          	   120:     jsr print_banked_address
                        	   121:     
                        	   122: done_testing_banked_rom:
00:CA31 20CFC3          	   123:     jsr move_cursor_to_next_line
                        	   124: 
00:CA34 60              	   125:     rts
                        	   126:     
                        	   127:     
                        	   128:     
                        	   129:     
                        	   130: ; Note: this function is copied to RAM so we can switch to a different ROM bank (and switch back afterwards)
                        	   131: test_rom_bank:
                        	   132: 
                        	   133:     ; Switching ROM BANK
00:CA35 A612            	   134:     ldx BANK_TESTING
00:CA37 8601            	   135:     stx ROM_BANK
                        	   136: ; FIXME: remove nop!
00:CA39 EA              	   137:     nop
                        	   138: 
                        	   139:     ; --- Testing a range of ROM (one block of 256 bytes at a time)
                        	   140: 
00:CA3A A900            	   141:     lda #0
00:CA3C 8514            	   142:     sta MEMORY_ADDR_TESTING
00:CA3E A610            	   143:     ldx START_ADDR_HIGH
                        	   144:     
                        	   145: check_next_rom_block:
00:CA40 8615            	   146:     stx MEMORY_ADDR_TESTING+1
                        	   147: 
00:CA42 A000            	   148:     ldy #0
                        	   149: check_rom_block:
00:CA44 B114            	   150:     lda (MEMORY_ADDR_TESTING), y
00:CA46 C512            	   151:     cmp BANK_TESTING
00:CA48 D00F            	   152:     bne rom_is_not_ok
00:CA4A C8              	   153:     iny
00:CA4B D0F7            	   154:     bne check_rom_block
                        	   155:     
00:CA4D E8              	   156:     inx
00:CA4E E411            	   157:     cpx END_ADDR_HIGH
00:CA50 D0EE            	   158:     bne check_next_rom_block
                        	   159:     
00:CA52 38              	   160:     sec   ; We set the carry flag: 'ok'
                        	   161:     
                        	   162:     ; Switching bank to ROM bank 0
00:CA53 A200            	   163:     ldx #$00
00:CA55 8601            	   164:     stx ROM_BANK
                        	   165: ; FIXME: remove nop!
00:CA57 EA              	   166:     nop
00:CA58 60              	   167:     rts
                        	   168: rom_is_not_ok:
                        	   169:     ; Currently used to trigger an LA
00:CA59 8D609F          	   170:     sta IO3_BASE_ADDRESS
                        	   171: 
00:CA5C 18              	   172:     clc    ; We clear the carry flag: 'not ok'
                        	   173:     
                        	   174:     ; Switching bank to ROM bank 0
00:CA5D A200            	   175:     ldx #$00
00:CA5F 8601            	   176:     stx ROM_BANK
                        	   177: ; FIXME: remove nop!
00:CA61 EA              	   178:     nop
00:CA62 60              	   179:     rts
                        	   180: end_of_test_rom_bank:

Source: "x16_hardware_tester.s"
                        	   145:     .include tests/vera_video_tests.s

Source: "tests\vera_video_tests.s"
                        	     1: ; Tests for checking functionality of VERA Video
                        	     2: 
                        	     3: vera_video_header: 
00:CA63 56455241202D2056	     4:     .asciiz "VERA - Video:"
00:CA6B 6964656F3A
00:CA70 00
                        	     5: testing_vram_message: 
                        	     6: ; FIXME: extend this range!
00:CA71 54657374696E6720	     7:     .asciiz "Testing VRAM ($00000 - $1F8FF) ... "
00:CA79 5652414D20282430
00:CA81 30303030202D2024
00:CA89 314638464629202E
00:CA91 2E2E20
00:CA94 00
                        	     8: testing_vsync_irq_message: 
00:CA95 54657374696E6720	     9:     .asciiz "Testing VSync interrupts ... "
00:CA9D 5653796E6320696E
00:CAA5 7465727275707473
00:CAAD 202E2E2E20
00:CAB2 00
                        	    10: testing_measure_cpu_speed_using_vsync_message: 
00:CAB3 4D6561737572696E	    11:     .asciiz "Measuring CPU clock speed using VSync ... "
00:CABB 672043505520636C
00:CAC3 6F636B2073706565
00:CACB 64207573696E6720
00:CAD3 5653796E63202E2E
00:CADB 2E20
00:CADD 00
                        	    12: testing_measure_cpu_speed_using_pcm_message: 
00:CADE 4D6561737572696E	    13:     .asciiz "Measuring CPU clock speed using PCM buffer ... "
00:CAE6 672043505520636C
00:CAEE 6F636B2073706565
00:CAF6 64207573696E6720
00:CAFE 50434D2062756666
00:CB06 6572202E2E2E20
00:CB0D 00
                        	    14: mhz_message:
00:CB0E 4D487A          	    15:     .asciiz "MHz"
00:CB11 00
                        	    16: too_high_message:
00:CB12 746F6F2068696768	    17:      .asciiz "too high"
00:CB1A 00
                        	    18: too_low_message:
00:CB1B 746F6F206C6F77  	    19:      .asciiz "too low"
00:CB22 00
                        	    20: no_buffer_fill_message:
00:CB23 6E6F206275666665	    21:      .asciiz "no buffer fill"
00:CB2B 722066696C6C
00:CB31 00
                        	    22:    
                        	    23: print_vera_video_header:
00:CB32 A902            	    24:     lda #MARGIN
00:CB34 850B            	    25:     sta INDENTATION
00:CB36 8509            	    26:     sta CURSOR_X
                        	    27:     
00:CB38 A60A            	    28:     ldx CURSOR_Y
00:CB3A E8              	    29:     inx
00:CB3B 860A            	    30:     stx CURSOR_Y
                        	    31:     
00:CB3D A947            	    32:     lda #COLOR_HEADER
00:CB3F 8508            	    33:     sta TEXT_COLOR
00:CB41 A963            	    34:     lda #<vera_video_header
00:CB43 8506            	    35:     sta TEXT_TO_PRINT
00:CB45 A9CA            	    36:     lda #>vera_video_header
00:CB47 8507            	    37:     sta TEXT_TO_PRINT + 1
                        	    38: 
00:CB49 20ECC3          	    39:     jsr print_text_zero
                        	    40:     
00:CB4C A904            	    41:     lda #(MARGIN+INDENT_SIZE)
00:CB4E 850B            	    42:     sta INDENTATION
                        	    43:     
00:CB50 20CFC3          	    44:     jsr move_cursor_to_next_line
                        	    45:     
00:CB53 60              	    46:     rts
                        	    47:     
                        	    48: lower_vram_not_ok_jmp:
00:CB54 4C3ACC          	    49:     jmp lower_vram_not_ok
                        	    50:     
                        	    51: test_vram:
                        	    52: 
                        	    53:     ; IMPORTANT: when trying to read and write to VERA, we should trigger a *reload* of the register that we want to *r
                        	    54:     ;             this is because it sets the DATA value at the moment the *write* occurs ***BEFORE*** it was changed!!
                        	    55: 
00:CB57 A941            	    56:     lda #COLOR_NORMAL
00:CB59 8508            	    57:     sta TEXT_COLOR
                        	    58:     
00:CB5B A971            	    59:     lda #<testing_vram_message
00:CB5D 8506            	    60:     sta TEXT_TO_PRINT
00:CB5F A9CA            	    61:     lda #>testing_vram_message
00:CB61 8507            	    62:     sta TEXT_TO_PRINT + 1
                        	    63:     
00:CB63 20ECC3          	    64:     jsr print_text_zero
                        	    65:     
                        	    66:     ; Start with checking the first 64KB of VRAM
                        	    67:     
00:CB66 2088CC          	    68:     jsr setup_vram_address_00000
                        	    69: 
00:CB69 A200            	    70:     ldx #0
                        	    71: next_vram_block_FF:
                        	    72: 
00:CB6B A000            	    73:     ldy #0
                        	    74: next_vram_byte_FF:
00:CB6D A9FF            	    75:     lda #$FF
00:CB6F 8D249F          	    76:     sta VERA_DATA1           ; Write byte
                        	    77:     
                        	    78:     ; This will trigger a reload of VERA_DATA0!
00:CB72 A910            	    79:     lda #%00010000           ; Setting bit 16 of vram address to 0, setting auto-increment value to 1
00:CB74 8D229F          	    80:     sta VERA_ADDR_BANK
                        	    81:     
00:CB77 AD239F          	    82:     lda VERA_DATA0           ; Read byte
00:CB7A C9FF            	    83:     cmp #$FF
00:CB7C D0D6            	    84:     bne lower_vram_not_ok_jmp
                        	    85:     
00:CB7E C8              	    86:     iny
00:CB7F D0EC            	    87:     bne next_vram_byte_FF
00:CB81 E8              	    88:     inx
00:CB82 D0E7            	    89:     bne next_vram_block_FF
                        	    90:     
00:CB84 2088CC          	    91:     jsr setup_vram_address_00000
                        	    92:     
00:CB87 A200            	    93:     ldx #0
                        	    94: next_vram_block_00:
                        	    95: 
00:CB89 A000            	    96:     ldy #0
                        	    97: next_vram_byte_00:
00:CB8B A900            	    98:     lda #$00
00:CB8D 8D249F          	    99:     sta VERA_DATA1           ; Write byte
                        	   100:     
                        	   101:     ; This will trigger a reload of VERA_DATA0!
00:CB90 A910            	   102:     lda #%00010000           ; Setting bit 16 of vram address to 0, setting auto-increment value to 1
00:CB92 8D229F          	   103:     sta VERA_ADDR_BANK
                        	   104: 
00:CB95 AD239F          	   105:     lda VERA_DATA0           ; Read byte
00:CB98 C900            	   106:     cmp #$00
00:CB9A D0B8            	   107:     bne lower_vram_not_ok_jmp
                        	   108:     
00:CB9C C8              	   109:     iny
00:CB9D D0EC            	   110:     bne next_vram_byte_00
00:CB9F E8              	   111:     inx
00:CBA0 D0E7            	   112:     bne next_vram_block_00
                        	   113:     
00:CBA2 205CCC          	   114:     jsr copy_tiles_and_map_to_low_vram
                        	   115: 
00:CBA5 A958            	   116:     lda #($0B0 >> 1)         ; Set mapbase for layer 0 to 0x0B000. This also sets the tile width and height to 8 px
00:CBA7 8D2E9F          	   117:     sta VERA_L0_MAPBASE
                        	   118:     
00:CBAA A978            	   119:     lda #($0F0 >> 1)         ; Set tilebase for layer 0 to 0x0F000. This also sets the tile width and height to 8 px
00:CBAC 8D2F9F          	   120:     sta VERA_L0_TILEBASE
                        	   121:     
00:CBAF 20B1CC          	   122:     jsr setup_vram_address_10000
                        	   123:     
00:CBB2 A200            	   124:     ldx #0
                        	   125: next_vram_block_high_FF:
                        	   126: 
00:CBB4 A000            	   127:     ldy #0
                        	   128: next_vram_byte_high_FF:
00:CBB6 A9FF            	   129:     lda #$FF
00:CBB8 8D249F          	   130:     sta VERA_DATA1           ; Write byte
                        	   131:     
                        	   132:     ; This will trigger a reload of VERA_DATA0!
00:CBBB A911            	   133:     lda #%00010001           ; Setting bit 16 of vram address to 1, setting auto-increment value to 1
00:CBBD 8D229F          	   134:     sta VERA_ADDR_BANK
                        	   135: 
00:CBC0 AD239F          	   136:     lda VERA_DATA0           ; Read byte
00:CBC3 C9FF            	   137:     cmp #$FF
00:CBC5 D047            	   138:     bne upper_vram_not_ok
                        	   139:     
00:CBC7 C8              	   140:     iny
00:CBC8 D0EC            	   141:     bne next_vram_byte_high_FF
00:CBCA E8              	   142:     inx
00:CBCB E0F9            	   143:     cpx #$F9
00:CBCD D0E5            	   144:     bne next_vram_block_high_FF
                        	   145:     
00:CBCF 20B1CC          	   146:     jsr setup_vram_address_10000
00:CBD2 A200            	   147:     ldx #0
                        	   148: next_vram_block_high_00:
                        	   149: 
00:CBD4 A000            	   150:     ldy #0
                        	   151: next_vram_byte_high_00:
00:CBD6 A900            	   152:     lda #$00
00:CBD8 8D249F          	   153:     sta VERA_DATA1           ; Write byte
                        	   154:     
                        	   155:     ; This will trigger a reload of VERA_DATA0!
00:CBDB A911            	   156:     lda #%00010001           ; Setting bit 16 of vram address to 1, setting auto-increment value to 1
00:CBDD 8D229F          	   157:     sta VERA_ADDR_BANK
                        	   158: 
00:CBE0 AD239F          	   159:     lda VERA_DATA0           ; Read byte
00:CBE3 C900            	   160:     cmp #$00
00:CBE5 D027            	   161:     bne upper_vram_not_ok
                        	   162:     
00:CBE7 C8              	   163:     iny
00:CBE8 D0EC            	   164:     bne next_vram_byte_high_00
00:CBEA E8              	   165:     inx
00:CBEB E0F9            	   166:     cpx #$F9
00:CBED D0E5            	   167:     bne next_vram_block_high_00
                        	   168:     
                        	   169:     ; FIXME: also check $1F900 - $1F9BF!!
                        	   170:     
00:CBEF 2072CC          	   171:     jsr copy_back_tiles_and_map_to_high_vram
                        	   172:     
00:CBF2 A9D8            	   173:     lda #($1B0 >> 1)         ; Set mapbase for layer 0 to 0x1B000. This also sets the tile width and height to 8 px
00:CBF4 8D2E9F          	   174:     sta VERA_L0_MAPBASE
                        	   175:     
00:CBF7 A9F8            	   176:     lda #($1F0 >> 1)         ; Set tilebase for layer 0 to 0x1F000. This also sets the tile width and height to 8 px
00:CBF9 8D2F9F          	   177:     sta VERA_L0_TILEBASE
                        	   178: 
                        	   179:     ; -- Printing 'OK'
                        	   180:     
00:CBFC A945            	   181:     lda #COLOR_OK
00:CBFE 8508            	   182:     sta TEXT_COLOR
                        	   183:     
00:CC00 A9B9            	   184:     lda #<ok_message
00:CC02 8506            	   185:     sta TEXT_TO_PRINT
00:CC04 A9C3            	   186:     lda #>ok_message
00:CC06 8507            	   187:     sta TEXT_TO_PRINT + 1
                        	   188:     
00:CC08 20ECC3          	   189:     jsr print_text_zero
                        	   190:     
00:CC0B 4C58CC          	   191:     jmp done_vram_test
                        	   192:     
                        	   193: upper_vram_not_ok:
                        	   194:     ; We preserve the bad value into a ZP register
00:CC0E 851A            	   195:     sta BAD_VALUE
                        	   196: 
                        	   197:     ; We want to keep x and y, so we put them on the stack
00:CC10 8A              	   198:     txa
00:CC11 48              	   199:     pha
00:CC12 98              	   200:     tya
00:CC13 48              	   201:     pha
                        	   202:     
                        	   203:     ; Since we were testing the upper vram, we must have copied our tiles and map, so we need to restore that first
00:CC14 2072CC          	   204:     jsr copy_back_tiles_and_map_to_high_vram
                        	   205:     
00:CC17 68              	   206:     pla
00:CC18 A8              	   207:     tay
00:CC19 68              	   208:     pla
00:CC1A AA              	   209:     tax
                        	   210:     
00:CC1B A9D8            	   211:     lda #($1B0 >> 1)         ; Set mapbase for layer 0 to 0x1B000. This also sets the tile width and height to 8 px
00:CC1D 8D2E9F          	   212:     sta VERA_L0_MAPBASE
                        	   213:     
00:CC20 A9F8            	   214:     lda #($1F0 >> 1)         ; Set tilebase for layer 0 to 0x1F000. This also sets the tile width and height to 8 px
00:CC22 8D2F9F          	   215:     sta VERA_L0_TILEBASE
                        	   216:     
00:CC25 A942            	   217:     lda #COLOR_ERROR
00:CC27 8508            	   218:     sta TEXT_COLOR
                        	   219:     
00:CC29 A9BC            	   220:     lda #<not_ok_message
00:CC2B 8506            	   221:     sta TEXT_TO_PRINT
00:CC2D A9C3            	   222:     lda #>not_ok_message
00:CC2F 8507            	   223:     sta TEXT_TO_PRINT + 1
                        	   224:     
00:CC31 20ECC3          	   225:     jsr print_text_zero
                        	   226:     
                        	   227:     ; This uses x as high byte and y as low byte of the address to print    
00:CC34 20CFC5          	   228:     jsr print_upper_vram_address
                        	   229:     
00:CC37 4C58CC          	   230:     jmp done_vram_test
                        	   231: 
                        	   232: lower_vram_not_ok:
                        	   233:     ; We preserve the bad value into a ZP register
00:CC3A 851A            	   234:     sta BAD_VALUE
                        	   235:     
00:CC3C A9D8            	   236:     lda #($1B0 >> 1)         ; Set mapbase for layer 0 to 0x1B000. This also sets the tile width and height to 8 px
00:CC3E 8D2E9F          	   237:     sta VERA_L0_MAPBASE
                        	   238:     
00:CC41 A9F8            	   239:     lda #($1F0 >> 1)         ; Set tilebase for layer 0 to 0x1F000. This also sets the tile width and height to 8 px
00:CC43 8D2F9F          	   240:     sta VERA_L0_TILEBASE
                        	   241:     
00:CC46 A942            	   242:     lda #COLOR_ERROR
00:CC48 8508            	   243:     sta TEXT_COLOR
                        	   244:     
00:CC4A A9BC            	   245:     lda #<not_ok_message
00:CC4C 8506            	   246:     sta TEXT_TO_PRINT
00:CC4E A9C3            	   247:     lda #>not_ok_message
00:CC50 8507            	   248:     sta TEXT_TO_PRINT + 1
                        	   249:     
00:CC52 20ECC3          	   250:     jsr print_text_zero
                        	   251:     
                        	   252:     ; This uses x as high byte and y as low byte of the address to print    
00:CC55 2066C5          	   253:     jsr print_lower_vram_address
                        	   254:     
                        	   255: done_vram_test:
00:CC58 20CFC3          	   256:     jsr move_cursor_to_next_line
                        	   257:     
00:CC5B 60              	   258:     rts
                        	   259:     
                        	   260:     
                        	   261: copy_tiles_and_map_to_low_vram:
                        	   262: 
                        	   263:     ; Copying $1B000-$1F7FF -> $0B000-$0F7FF
                        	   264:     
00:CC5C 20DACC          	   265:     jsr setup_vram_address_copy
                        	   266:     
00:CC5F A2B0            	   267:     ldx #$B0
                        	   268: next_vram_block_copy:
                        	   269: 
00:CC61 A000            	   270:     ldy #0
                        	   271: next_vram_byte_copy:
                        	   272:     
00:CC63 AD249F          	   273:     lda VERA_DATA1           ; Read byte
00:CC66 8D239F          	   274:     sta VERA_DATA0           ; Write byte
                        	   275:     
00:CC69 C8              	   276:     iny
00:CC6A D0F7            	   277:     bne next_vram_byte_copy
00:CC6C E8              	   278:     inx
00:CC6D E0F8            	   279:     cpx #$F8
00:CC6F D0F0            	   280:     bne next_vram_block_copy
                        	   281:     
00:CC71 60              	   282:     rts
                        	   283: 
                        	   284: copy_back_tiles_and_map_to_high_vram:
                        	   285: 
                        	   286:     ; Copying $0B000-$0F7FF -> $1B000-$1F7FF
                        	   287:     
00:CC72 20DACC          	   288:     jsr setup_vram_address_copy
                        	   289:     
00:CC75 A2B0            	   290:     ldx #$B0
                        	   291: next_vram_block_copy_back:
                        	   292: 
00:CC77 A000            	   293:     ldy #0
                        	   294: next_vram_byte_copy_back:
                        	   295:     
00:CC79 AD239F          	   296:     lda VERA_DATA0           ; Read byte
00:CC7C 8D249F          	   297:     sta VERA_DATA1           ; Write byte
                        	   298:     
00:CC7F C8              	   299:     iny
00:CC80 D0F7            	   300:     bne next_vram_byte_copy_back
00:CC82 E8              	   301:     inx
00:CC83 E0F8            	   302:     cpx #$F8
00:CC85 D0F0            	   303:     bne next_vram_block_copy_back
                        	   304:     
00:CC87 60              	   305:     rts
                        	   306:     
                        	   307:     
                        	   308: setup_vram_address_00000:
                        	   309: 
00:CC88 A901            	   310:     lda #%00000001           ; DCSEL=0, ADDRSEL=1
00:CC8A 8D259F          	   311:     sta VERA_CTRL
                        	   312: 
00:CC8D A910            	   313:     lda #%00010000           ; Setting bit 16 of vram address to 0, setting auto-increment value to 1
00:CC8F 8D229F          	   314:     sta VERA_ADDR_BANK
00:CC92 A900            	   315:     lda #$00
00:CC94 8D219F          	   316:     sta VERA_ADDR_HIGH
00:CC97 A900            	   317:     lda #$00
00:CC99 8D209F          	   318:     sta VERA_ADDR_LOW
                        	   319:     
00:CC9C A900            	   320:     lda #%00000000           ; DCSEL=0, ADDRSEL=0
00:CC9E 8D259F          	   321:     sta VERA_CTRL
                        	   322:     
00:CCA1 A910            	   323:     lda #%00010000           ; Setting bit 16 of vram address to 0, setting auto-increment value to 1
00:CCA3 8D229F          	   324:     sta VERA_ADDR_BANK
00:CCA6 A900            	   325:     lda #$00
00:CCA8 8D219F          	   326:     sta VERA_ADDR_HIGH
00:CCAB A900            	   327:     lda #$00
00:CCAD 8D209F          	   328:     sta VERA_ADDR_LOW
                        	   329: 
00:CCB0 60              	   330:     rts
                        	   331:     
                        	   332: setup_vram_address_10000:
                        	   333: 
00:CCB1 A901            	   334:     lda #%00000001           ; DCSEL=0, ADDRSEL=1
00:CCB3 8D259F          	   335:     sta VERA_CTRL
                        	   336: 
00:CCB6 A911            	   337:     lda #%00010001           ; Setting bit 16 of vram address to 1, setting auto-increment value to 1
00:CCB8 8D229F          	   338:     sta VERA_ADDR_BANK
00:CCBB A900            	   339:     lda #$00
00:CCBD 8D219F          	   340:     sta VERA_ADDR_HIGH
00:CCC0 A900            	   341:     lda #$00
00:CCC2 8D209F          	   342:     sta VERA_ADDR_LOW
                        	   343:     
00:CCC5 A900            	   344:     lda #%00000000           ; DCSEL=0, ADDRSEL=0
00:CCC7 8D259F          	   345:     sta VERA_CTRL
                        	   346:     
00:CCCA A911            	   347:     lda #%00010001           ; Setting bit 16 of vram address to 1, setting auto-increment value to 1
00:CCCC 8D229F          	   348:     sta VERA_ADDR_BANK
00:CCCF A900            	   349:     lda #$00
00:CCD1 8D219F          	   350:     sta VERA_ADDR_HIGH
00:CCD4 A900            	   351:     lda #$00
00:CCD6 8D209F          	   352:     sta VERA_ADDR_LOW
                        	   353: 
00:CCD9 60              	   354:     rts
                        	   355:     
                        	   356: setup_vram_address_copy:
                        	   357: 
00:CCDA A901            	   358:     lda #%00000001           ; DCSEL=0, ADDRSEL=1
00:CCDC 8D259F          	   359:     sta VERA_CTRL
                        	   360: 
00:CCDF A911            	   361:     lda #%00010001           ; Setting bit 16 of vram address to 1, setting auto-increment value to 1
00:CCE1 8D229F          	   362:     sta VERA_ADDR_BANK
00:CCE4 A9B0            	   363:     lda #$B0                 ; Start of tile map
00:CCE6 8D219F          	   364:     sta VERA_ADDR_HIGH
00:CCE9 A900            	   365:     lda #$00
00:CCEB 8D209F          	   366:     sta VERA_ADDR_LOW
                        	   367:     
00:CCEE A900            	   368:     lda #%00000000           ; DCSEL=0, ADDRSEL=0
00:CCF0 8D259F          	   369:     sta VERA_CTRL
                        	   370:     
00:CCF3 A910            	   371:     lda #%00010000           ; Setting bit 16 of vram address to 0, setting auto-increment value to 1
00:CCF5 8D229F          	   372:     sta VERA_ADDR_BANK
00:CCF8 A9B0            	   373:     lda #$B0
00:CCFA 8D219F          	   374:     sta VERA_ADDR_HIGH
00:CCFD A900            	   375:     lda #$00
00:CCFF 8D209F          	   376:     sta VERA_ADDR_LOW
                        	   377: 
00:CD02 60              	   378:     rts
                        	   379:     
                        	   380:     
                        	   381: measure_cpu_speed_using_pcm:
                        	   382: 
                        	   383:     ; We are trying to determine the CPU clock speed based on the rate of emptying of the PCM FIFO buffer (using VERA)
                        	   384:     
00:CD03 A941            	   385:     lda #COLOR_NORMAL
00:CD05 8508            	   386:     sta TEXT_COLOR
                        	   387:     
00:CD07 A9DE            	   388:     lda #<testing_measure_cpu_speed_using_pcm_message
00:CD09 8506            	   389:     sta TEXT_TO_PRINT
00:CD0B A9CA            	   390:     lda #>testing_measure_cpu_speed_using_pcm_message
00:CD0D 8507            	   391:     sta TEXT_TO_PRINT + 1
                        	   392:     
00:CD0F 20ECC3          	   393:     jsr print_text_zero
                        	   394:     
                        	   395:     ; We reset the FIFO and configure it
00:CD12 A980            	   396:     lda #%10000000  ; FIFO Reset, 8-bit, Mono, no volume
00:CD14 8D3B9F          	   397:     sta VERA_AUDIO_CTRL
                        	   398:     
                        	   399:     ; We set the PCM sample rate to 0 (no sampling)
00:CD17 A900            	   400:     lda #$00
00:CD19 8D3C9F          	   401:     sta VERA_AUDIO_RATE
                        	   402:     
                        	   403:     ; We fill the PCM buffer with 4KB (= 16 * 256 bytes) of data
                        	   404: 
00:CD1C A900            	   405:     lda #$00  ; It really doesn't matter where we fill it with
00:CD1E A010            	   406:     ldy #16
                        	   407: fill_pcm_audio_block_with_ff:
00:CD20 A200            	   408:     ldx #0
                        	   409: fill_pcm_audio_byte_with_ff:
00:CD22 8D3D9F          	   410:     sta VERA_AUDIO_DATA
00:CD25 E8              	   411:     inx
00:CD26 D0FA            	   412:     bne fill_pcm_audio_byte_with_ff
00:CD28 88              	   413:     dey
00:CD29 D0F5            	   414:     bne fill_pcm_audio_block_with_ff
                        	   415:     
00:CD2B AD3B9F          	   416:     lda VERA_AUDIO_CTRL
00:CD2E 1072            	   417:     bpl audio_buffer_is_not_full ; If bit 7 is not set the audio FIFO buffer is not full. We didnt expect that, since w
                        	   418:     
                        	   419:     ; The buffer is full. We will now start "playback" by setting a sampling rate. We then do a fixed amount of CPU cyc
                        	   420:     
                        	   421:     ; -- Start playback
00:CD30 A943            	   422:     lda #67 ; Slightly more than 64 (=24414 Hz). Using 24414Hz it would play exactly 256 bytes at 8MHz. We want a littl
00:CD32 8D3C9F          	   423:     sta VERA_AUDIO_RATE
                        	   424:     
                        	   425:     ; We loop 64*256 times
00:CD35 A040            	   426:     ldy #64
                        	   427: wait_block_during_pcm_playback:
00:CD37 A200            	   428:     ldx #0
                        	   429: wait_single_during_pcm_playback:
00:CD39 E8              	   430:     inx
00:CD3A D0FD            	   431:     bne wait_single_during_pcm_playback
00:CD3C 88              	   432:     dey
00:CD3D D0F8            	   433:     bne wait_block_during_pcm_playback
                        	   434:     
                        	   435:     ; -- Stop playback
00:CD3F A900            	   436:     lda #$00
00:CD41 8D3C9F          	   437:     sta VERA_AUDIO_RATE
                        	   438:     
                        	   439:     ; We fill the PCM buffer again, but now we keep checking if its full: that we know how many bytes it sampled/played
00:CD44 A900            	   440:     lda #0
00:CD46 8520            	   441:     sta TIMING_COUNTER
00:CD48 8521            	   442:     sta TIMING_COUNTER+1
                        	   443:     
00:CD4A A900            	   444:     lda #0 ; It really doesn't matter where we fill it with
                        	   445: fill_pcm_audio_byte:
00:CD4C 8D3D9F          	   446:     sta VERA_AUDIO_DATA
00:CD4F E620            	   447:     inc TIMING_COUNTER
00:CD51 D002            	   448:     bne no_increment_counter_pcm
00:CD53 E621            	   449:     inc TIMING_COUNTER+1    
                        	   450: no_increment_counter_pcm:
00:CD55 AD3B9F          	   451:     lda VERA_AUDIO_CTRL
00:CD58 10F2            	   452:     bpl fill_pcm_audio_byte ; If bit 7 is not set the audio FIFO buffer is not full. So we repeat
                        	   453:     
00:CD5A A621            	   454:     ldx TIMING_COUNTER+1
                        	   455:     
                        	   456:     ; Approx expected values of counter:
                        	   457:     ; $0100 : 8MHz
                        	   458:     ; $0200 : 4MHz
                        	   459:     ; $0400 : 2MHz
                        	   460:     ; $0800 : 1MHz
                        	   461:     
00:CD5C A901            	   462:     lda #1                  ; We start at 1 MHz
00:CD5E E008            	   463:     cpx #8                  ; 8 * 256 bytes played (full buffer) -> 1MHz
00:CD60 B015            	   464:     bcs cpu_speed_done_pcm  ; We got more or equal counts so we are at 1MHz
00:CD62 A902            	   465:     lda #2                  ; We assume 2 MHz now
00:CD64 E004            	   466:     cpx #4                  ; 4 * 256 bytes played (half of a buffer) -> 2MHz
00:CD66 B00F            	   467:     bcs cpu_speed_done_pcm  ; We got more or equal counts so we are at 2MHz
00:CD68 A904            	   468:     lda #4                  ; We assume 4 MHz now
00:CD6A E002            	   469:     cpx #2                  ; 2 * 256 bytes played (quarter of a buffer) -> 4MHz
00:CD6C B009            	   470:     bcs cpu_speed_done_pcm  ; We got more or equal counts so we are at 4MHz
00:CD6E A908            	   471:     lda #8                  ; We assume 8 MHz now
00:CD70 E001            	   472:     cpx #1                  ; 1 * 256 bytes played (an eighth of a buffer) -> 8MHz
00:CD72 B003            	   473:     bcs cpu_speed_done_pcm  ; We got more or equal counts so we are at 4MHz
00:CD74 4C90CD          	   474:     jmp cpu_speed_too_high_pcm
                        	   475:     
                        	   476: cpu_speed_done_pcm:
00:CD77 8523            	   477:     sta ESTIMATED_CPU_SPEED_PCM
                        	   478:     
                        	   479: measured_ok_cpu_speed_pcm:
                        	   480:     ; We measure the CPU speed, so we are reporting it here
00:CD79 A945            	   481:     lda #COLOR_OK
00:CD7B 8508            	   482:     sta TEXT_COLOR
                        	   483: 
00:CD7D A523            	   484:     lda ESTIMATED_CPU_SPEED_PCM
00:CD7F 2025C4          	   485:     jsr print_byte_as_decimal        
                        	   486: 
00:CD82 A90E            	   487:     lda #<mhz_message
00:CD84 8506            	   488:     sta TEXT_TO_PRINT
00:CD86 A9CB            	   489:     lda #>mhz_message
00:CD88 8507            	   490:     sta TEXT_TO_PRINT + 1
                        	   491:     
00:CD8A 20ECC3          	   492:     jsr print_text_zero
                        	   493: 
00:CD8D 4CB1CD          	   494:     jmp done_measuring_cpu_speed_pcm
                        	   495: 
                        	   496: cpu_speed_too_high_pcm:
                        	   497: 
                        	   498:     ; We filled the buffer with 4KB of data but the PCM buffer was not full
00:CD90 A942            	   499:     lda #COLOR_ERROR
00:CD92 8508            	   500:     sta TEXT_COLOR
                        	   501: 
00:CD94 A912            	   502:     lda #<too_high_message
00:CD96 8506            	   503:     sta TEXT_TO_PRINT
00:CD98 A9CB            	   504:     lda #>too_high_message
00:CD9A 8507            	   505:     sta TEXT_TO_PRINT + 1
                        	   506:     
00:CD9C 20ECC3          	   507:     jsr print_text_zero
                        	   508:     
00:CD9F 4CB1CD          	   509:     jmp done_measuring_cpu_speed_pcm
                        	   510:     
                        	   511: audio_buffer_is_not_full:
                        	   512: 
                        	   513:     ; We filled the buffer with 4KB of data but the PCM buffer was not full
00:CDA2 A942            	   514:     lda #COLOR_ERROR
00:CDA4 8508            	   515:     sta TEXT_COLOR
                        	   516: 
00:CDA6 A923            	   517:     lda #<no_buffer_fill_message
00:CDA8 8506            	   518:     sta TEXT_TO_PRINT
00:CDAA A9CB            	   519:     lda #>no_buffer_fill_message
00:CDAC 8507            	   520:     sta TEXT_TO_PRINT + 1
                        	   521:     
00:CDAE 20ECC3          	   522:     jsr print_text_zero
                        	   523:     
                        	   524: done_measuring_cpu_speed_pcm:
00:CDB1 20CFC3          	   525:     jsr move_cursor_to_next_line
                        	   526:     
                        	   527: 
00:CDB4 60              	   528:     rts
                        	   529:     
                        	   530: measure_cpu_speed_using_vsync:
                        	   531: 
                        	   532:     ; We are trying to determine the CPU clock speed based on VSync interrupts from VERA 
                        	   533: 
00:CDB5 A941            	   534:     lda #COLOR_NORMAL
00:CDB7 8508            	   535:     sta TEXT_COLOR
                        	   536:     
00:CDB9 A995            	   537:     lda #<testing_vsync_irq_message
00:CDBB 8506            	   538:     sta TEXT_TO_PRINT
00:CDBD A9CA            	   539:     lda #>testing_vsync_irq_message
00:CDBF 8507            	   540:     sta TEXT_TO_PRINT + 1
                        	   541:     
00:CDC1 20ECC3          	   542:     jsr print_text_zero
                        	   543: 
                        	   544:     ; Copy irq default code to RAM
                        	   545: 
00:CDC4 A200            	   546:     ldx #0
                        	   547: copy_irq_cpu_speed_measurment_code:
00:CDC6 BD8ACE          	   548:     lda irq_cpu_speed_measurment, x
00:CDC9 9D0010          	   549:     sta IRQ_RAM_ADDRES, x
00:CDCC E8              	   550:     inx 
00:CDCD E016            	   551:     cpx #(end_of_irq_cpu_speed_measurment-irq_cpu_speed_measurment)
00:CDCF D0F5            	   552:     bne copy_irq_cpu_speed_measurment_code
                        	   553: 
                        	   554:     ; We determine the CPU clock speed by measuring the amount of loops we can perform in 1 frame (using V-Sync)
                        	   555:     
00:CDD1 A900            	   556:     lda #0
00:CDD3 8520            	   557:     sta TIMING_COUNTER
00:CDD5 8521            	   558:     sta TIMING_COUNTER+1
00:CDD7 8522            	   559:     sta COUNTER_IS_RUNNING
                        	   560: 
00:CDD9 A907            	   561:     lda #%00000111 ; ACK any existing IRQs in VERA
00:CDDB 8D279F          	   562:     sta VERA_ISR
                        	   563:     ; Enable interupts
00:CDDE 58              	   564:     cli
                        	   565:     
00:CDDF A901            	   566:     lda #%00000001  ; enable only v-sync irq
00:CDE1 8D269F          	   567:     sta VERA_IEN
                        	   568:     
                        	   569:     ; We wait for the V-SYNC interrupt to start the counter (COUNTER_IS_RUNNING: 0 -> 1)
                        	   570: waiting_to_start_counter_vsync:
00:CDE4 E620            	   571:     inc TIMING_COUNTER
00:CDE6 D004            	   572:     bne waiting_no_increment_vsync
00:CDE8 E621            	   573:     inc TIMING_COUNTER+1
00:CDEA F06C            	   574:     beq waiting_too_long_vsync
                        	   575: waiting_no_increment_vsync:
00:CDEC A522            	   576:     lda COUNTER_IS_RUNNING
00:CDEE F0F4            	   577:     beq waiting_to_start_counter_vsync
                        	   578: 
00:CDF0 A900            	   579:     lda #0
00:CDF2 8520            	   580:     sta TIMING_COUNTER
00:CDF4 8521            	   581:     sta TIMING_COUNTER+1
                        	   582:     
                        	   583:     ; We start counting until 1 frame has passed (COUNTER_IS_RUNNING: 1 -> 0)
                        	   584: increment_counter:
00:CDF6 E620            	   585:     inc TIMING_COUNTER
00:CDF8 D002            	   586:     bne no_increment
00:CDFA E621            	   587:     inc TIMING_COUNTER+1
                        	   588: no_increment:
00:CDFC A522            	   589:     lda COUNTER_IS_RUNNING
00:CDFE D0F6            	   590:     bne increment_counter
                        	   591: 
                        	   592:     ; The interrupt turned off COUNTER_IS_RUNNING so the VSync interrupt worked
00:CE00 A945            	   593:     lda #COLOR_OK
00:CE02 8508            	   594:     sta TEXT_COLOR
                        	   595:     
00:CE04 A9B9            	   596:     lda #<ok_message
00:CE06 8506            	   597:     sta TEXT_TO_PRINT
00:CE08 A9C3            	   598:     lda #>ok_message
00:CE0A 8507            	   599:     sta TEXT_TO_PRINT + 1
                        	   600:     
00:CE0C 20ECC3          	   601:     jsr print_text_zero
                        	   602:     
00:CE0F 20CFC3          	   603:     jsr move_cursor_to_next_line
                        	   604: 
                        	   605:     ; At 8MHz the counter goes to 9580 ($256c) in one frame ~ 9600
                        	   606:     ; At 4Mhz ~ 4800
                        	   607:     ; At 2Mhz ~ 2400
                        	   608:     ; At 1Mhz ~ 1200
                        	   609:     
00:CE12 A941            	   610:     lda #COLOR_NORMAL
00:CE14 8508            	   611:     sta TEXT_COLOR
                        	   612:     
00:CE16 A9B3            	   613:     lda #<testing_measure_cpu_speed_using_vsync_message
00:CE18 8506            	   614:     sta TEXT_TO_PRINT
00:CE1A A9CA            	   615:     lda #>testing_measure_cpu_speed_using_vsync_message
00:CE1C 8507            	   616:     sta TEXT_TO_PRINT + 1
                        	   617:     
00:CE1E 20ECC3          	   618:     jsr print_text_zero
                        	   619:     
                        	   620:     ; We use the high byte of the counter
00:CE21 A621            	   621:     ldx TIMING_COUNTER+1
                        	   622:     
                        	   623: ; FIXME: if out of bounds (either too low or too high) we should make this an ERROR!
                        	   624:     
00:CE23 A908            	   625:     lda #8                    ; We start at 8 MHz
00:CE25 E01C            	   626:     cpx #$1C                  ; Value between 8 and 4 MHz: 7200 == $1C20 == $1C
00:CE27 B015            	   627:     bcs cpu_speed_done_vsync  ; We got more counts so we are at 8MHz
00:CE29 A904            	   628:     lda #4                    ; We assume 4 MHz now
00:CE2B E00E            	   629:     cpx #$0E                  ; Value between 4 and 2 MHz: 3600 == $0E10 == $0E
00:CE2D B00F            	   630:     bcs cpu_speed_done_vsync  ; We got more counts so we are at 4MHz
00:CE2F A902            	   631:     lda #2                    ; We assume 2 MHz now
00:CE31 E007            	   632:     cpx #$07                  ; Value between 2 and 1 MHz: 1800 == $0708 == $07
00:CE33 B009            	   633:     bcs cpu_speed_done_vsync  ; We got more counts so we are at 2MHz
00:CE35 A901            	   634:     lda #1                    ; We assume 1 MHz now
00:CE37 E003            	   635:     cpx #$03                  ; Value between 1 and 0.5 MHz: 900 == $0384 == $03
00:CE39 B003            	   636:     bcs cpu_speed_done_vsync  ; We got more counts so we are at 1MHz
00:CE3B 4C46CE          	   637:     jmp cpu_speed_too_low_vsync
                        	   638: 
                        	   639: cpu_speed_done_vsync:
00:CE3E 8524            	   640:     sta ESTIMATED_CPU_SPEED_VSYNC
                        	   641:     
                        	   642: measured_ok_cpu_speed_vsync:
                        	   643:     ; We measure the CPU speed, so we are reporting it here
00:CE40 206CCE          	   644:     jsr print_cpu_speed_vsync
                        	   645: 
00:CE43 4C67CE          	   646:     jmp done_measuring_cpu_speed_vsync
                        	   647: 
                        	   648: cpu_speed_too_low_vsync:
                        	   649: 
                        	   650:     ; We have a cpu speed that is too low
00:CE46 A942            	   651:     lda #COLOR_ERROR
00:CE48 8508            	   652:     sta TEXT_COLOR
                        	   653: 
00:CE4A A91B            	   654:     lda #<too_low_message
00:CE4C 8506            	   655:     sta TEXT_TO_PRINT
00:CE4E A9CB            	   656:     lda #>too_low_message
00:CE50 8507            	   657:     sta TEXT_TO_PRINT + 1
                        	   658:     
00:CE52 20ECC3          	   659:     jsr print_text_zero
                        	   660:     
00:CE55 4C67CE          	   661:     jmp done_measuring_cpu_speed_vsync
                        	   662:     
                        	   663: waiting_too_long_vsync:
                        	   664:     ; We waited for the interrupt to start the counter, but it took too long, Vsync interrupt must have failed
00:CE58 A942            	   665:     lda #COLOR_ERROR
00:CE5A 8508            	   666:     sta TEXT_COLOR
                        	   667: 
00:CE5C A9BC            	   668:     lda #<not_ok_message
00:CE5E 8506            	   669:     sta TEXT_TO_PRINT
00:CE60 A9C3            	   670:     lda #>not_ok_message
00:CE62 8507            	   671:     sta TEXT_TO_PRINT + 1
                        	   672:     
00:CE64 20ECC3          	   673:     jsr print_text_zero
                        	   674:     
                        	   675: done_measuring_cpu_speed_vsync:
                        	   676: 
00:CE67 20CFC3          	   677:     jsr move_cursor_to_next_line
                        	   678:     ; Disable interrupts 
00:CE6A 78              	   679:     sei
                        	   680:     
00:CE6B 60              	   681:     rts
                        	   682: 
                        	   683: print_cpu_speed_vsync:
00:CE6C C523            	   684:     cmp ESTIMATED_CPU_SPEED_PCM
00:CE6E D005            	   685:     bne cpu_speeds_differ
00:CE70 A945            	   686:     lda #COLOR_OK
00:CE72 4C77CE          	   687:     jmp color_cpu_speed_done
                        	   688: cpu_speeds_differ:
00:CE75 A942            	   689:     lda #COLOR_ERROR
                        	   690: color_cpu_speed_done:
00:CE77 8508            	   691:     sta TEXT_COLOR
                        	   692: 
00:CE79 A524            	   693:     lda ESTIMATED_CPU_SPEED_VSYNC
00:CE7B 2025C4          	   694:     jsr print_byte_as_decimal        
                        	   695: 
00:CE7E A90E            	   696:     lda #<mhz_message
00:CE80 8506            	   697:     sta TEXT_TO_PRINT
00:CE82 A9CB            	   698:     lda #>mhz_message
00:CE84 8507            	   699:     sta TEXT_TO_PRINT + 1
                        	   700:     
00:CE86 20ECC3          	   701:     jsr print_text_zero
                        	   702: 
00:CE89 60              	   703:     rts
                        	   704:     
                        	   705: irq_cpu_speed_measurment:
00:CE8A 48              	   706:     pha
                        	   707:     
                        	   708:     ; TODO: disable interrupts 
                        	   709:     
                        	   710:     ; TODO: we are not checking if VERA generated the IRQ (and if its a VSYNC interrupt). We should probably do that.
00:CE8B A522            	   711:     lda COUNTER_IS_RUNNING
00:CE8D F006            	   712:     beq start_counter
                        	   713:     ; The counter is running, we should stop it 
00:CE8F A900            	   714:     lda #0
00:CE91 8522            	   715:     sta COUNTER_IS_RUNNING
                        	   716:     
00:CE93 F004            	   717:     beq end_of_interrupt  ; since a = 0 we always do this (TODO: use 'bra' instead)
                        	   718: start_counter:
00:CE95 A901            	   719:     lda #1
00:CE97 8522            	   720:     sta COUNTER_IS_RUNNING
                        	   721: end_of_interrupt:
                        	   722:     ; clear V-SYNC and LINE interrupt (just to be sure)
00:CE99 A903            	   723:     lda #%00000011
00:CE9B 8D279F          	   724:     sta VERA_ISR
                        	   725:     
                        	   726:     ; TODO: enable interrupts 
                        	   727:     
00:CE9E 68              	   728:     pla
00:CE9F 40              	   729:     rti
                        	   730: end_of_irq_cpu_speed_measurment:
                        	   731: 

Source: "x16_hardware_tester.s"
                        	   146:     .include tests/vera_sd_tests.s

Source: "tests\vera_sd_tests.s"
                        	     1: ; Tests for checking functionality of VERA SD
                        	     2: 
                        	     3: ; We use this as basis for SD card communication using SPI:
                        	     4: ;   http://elm-chan.org/docs/mmc/mmc_e.html
                        	     5: 
                        	     6: ; We try to implement this chart for SD Card initialization:
                        	     7: ;   http://elm-chan.org/docs/mmc/m/sdinit.png
                        	     8: 
                        	     9: 
                        	    10: SPI_CHIP_DESELECT_AND_SLOW =   %00000010
                        	    11: SPI_CHIP_SELECT_AND_SLOW   =   %00000011
                        	    12: 
                        	    13: vera_sd_header: 
00:CEA0 56455241202D2053	    14:     .asciiz "VERA - SD:"
00:CEA8 443A
00:CEAA 00
                        	    15:     
                        	    16: vera_sd_reset_message:
00:CEAB 446574656374696E	    17:     .asciiz "Detecting and resetting SD Card ... "
00:CEB3 6720616E64207265
00:CEBB 73657474696E6720
00:CEC3 5344204361726420
00:CECB 2E2E2E20
00:CECF 00
                        	    18: vera_check_sdc_version_message:
00:CED0 436865636B696E67	    19:     .asciiz "Checking if card is SDC Ver.2+ ... "
00:CED8 2069662063617264
00:CEE0 2069732053444320
00:CEE8 5665722E322B202E
00:CEF0 2E2E20
00:CEF3 00
                        	    20: vera_sd_initialize_message:
00:CEF4 496E697469616C69	    21:     .asciiz "Initializing SD Card ... "
00:CEFC 7A696E6720534420
00:CF04 43617264202E2E2E
00:CF0C 20
00:CF0D 00
                        	    22: vera_sd_no_card_detected: 
00:CF0E 4E6F206361726420	    23:     .asciiz "No card detected"
00:CF16 6465746563746564
00:CF1E 00
                        	    24: vera_sd_timeout_message:    
00:CF1F 54696D656F7574  	    25:     .asciiz "Timeout"
00:CF26 00
                        	    26: 
                        	    27:    
                        	    28: print_vera_sd_header:
00:CF27 A902            	    29:     lda #MARGIN
00:CF29 850B            	    30:     sta INDENTATION
00:CF2B 8509            	    31:     sta CURSOR_X
                        	    32:     
00:CF2D A60A            	    33:     ldx CURSOR_Y
00:CF2F E8              	    34:     inx
00:CF30 860A            	    35:     stx CURSOR_Y
                        	    36:     
00:CF32 A947            	    37:     lda #COLOR_HEADER
00:CF34 8508            	    38:     sta TEXT_COLOR
00:CF36 A9A0            	    39:     lda #<vera_sd_header
00:CF38 8506            	    40:     sta TEXT_TO_PRINT
00:CF3A A9CE            	    41:     lda #>vera_sd_header
00:CF3C 8507            	    42:     sta TEXT_TO_PRINT + 1
                        	    43: 
00:CF3E 20ECC3          	    44:     jsr print_text_zero
                        	    45:     
00:CF41 A904            	    46:     lda #(MARGIN+INDENT_SIZE)
00:CF43 850B            	    47:     sta INDENTATION
                        	    48:     
00:CF45 20CFC3          	    49:     jsr move_cursor_to_next_line
                        	    50:     
00:CF48 60              	    51:     rts
                        	    52: 
                        	    53:     
                        	    54: ; ======= Initialize SD Card ========    
                        	    55: 
                        	    56: vera_initialize_sd_card:
                        	    57: 
00:CF49 A941            	    58:     lda #COLOR_NORMAL
00:CF4B 8508            	    59:     sta TEXT_COLOR
                        	    60:     
00:CF4D A9F4            	    61:     lda #<vera_sd_initialize_message
00:CF4F 8506            	    62:     sta TEXT_TO_PRINT
00:CF51 A9CE            	    63:     lda #>vera_sd_initialize_message
00:CF53 8507            	    64:     sta TEXT_TO_PRINT + 1
                        	    65:     
00:CF55 20ECC3          	    66:     jsr print_text_zero
                        	    67: 
                        	    68: 
                        	    69:     ; We send command 55 to prepare for command ACMD41
00:CF58 20DCD0          	    70:     jsr spi_send_command55
                        	    71:     
00:CF5B B012            	    72:     bcs command55_success
                        	    73: command55_timed_out:
                        	    74:     
                        	    75:     ; If carry is unset, we timed out. We print 'Timeout' as an error
00:CF5D A942            	    76:     lda #COLOR_ERROR
00:CF5F 8508            	    77:     sta TEXT_COLOR
                        	    78:     
00:CF61 A91F            	    79:     lda #<vera_sd_timeout_message
00:CF63 8506            	    80:     sta TEXT_TO_PRINT
00:CF65 A9CF            	    81:     lda #>vera_sd_timeout_message
00:CF67 8507            	    82:     sta TEXT_TO_PRINT + 1
                        	    83:     
00:CF69 20ECC3          	    84:     jsr print_text_zero
                        	    85: 
00:CF6C 4CADCF          	    86:     jmp done_with_initialize_do_not_proceed
                        	    87:     
                        	    88: command55_success:
                        	    89: 
                        	    90:     ; We got our byte of response. We check if the SD Card is not in an IDLE state (which is expected)
00:CF6F C901            	    91:     cmp #%0000001   ; IDLE state
00:CF71 D035            	    92:     bne command55_not_in_idle_state
                        	    93:     
                        	    94: 
                        	    95:     ; --- ACMD41 ---
                        	    96:     
                        	    97:     ; We send command ACMD41 to "initiate initialization with ACMD41 with HCS[bit30] flag in the argument"
00:CF73 2006D1          	    98:     jsr spi_send_command41
                        	    99:     
00:CF76 B012            	   100:     bcs command41_success
                        	   101: command41_timed_out:
                        	   102:     
                        	   103:     ; If carry is unset, we timed out. We print 'Timeout' as an error
00:CF78 A942            	   104:     lda #COLOR_ERROR
00:CF7A 8508            	   105:     sta TEXT_COLOR
                        	   106:     
00:CF7C A91F            	   107:     lda #<vera_sd_timeout_message
00:CF7E 8506            	   108:     sta TEXT_TO_PRINT
00:CF80 A9CF            	   109:     lda #>vera_sd_timeout_message
00:CF82 8507            	   110:     sta TEXT_TO_PRINT + 1
                        	   111:     
00:CF84 20ECC3          	   112:     jsr print_text_zero
                        	   113: 
00:CF87 4CADCF          	   114:     jmp done_with_initialize_do_not_proceed
                        	   115:     
                        	   116: command41_success:
                        	   117: 
                        	   118:     ; We got our byte of response. We check if the SD Card is not in an IDLE state (which is expected)
00:CF8A C900            	   119:     cmp #%0000000   ; NOT in IDLE state! (we just initialized, so we should not be in IDLE state anymore!)
00:CF8C D012            	   120:     bne command41_still_in_idle_state
                        	   121:     
00:CF8E A945            	   122:     lda #COLOR_OK
00:CF90 8508            	   123:     sta TEXT_COLOR
                        	   124:     
00:CF92 A9B9            	   125:     lda #<ok_message
00:CF94 8506            	   126:     sta TEXT_TO_PRINT
00:CF96 A9C3            	   127:     lda #>ok_message
00:CF98 8507            	   128:     sta TEXT_TO_PRINT + 1
                        	   129:     
00:CF9A 20ECC3          	   130:     jsr print_text_zero
                        	   131:     
00:CF9D 4CB7CF          	   132:     jmp done_with_initialize_proceed
                        	   133:     
                        	   134: command41_still_in_idle_state:
                        	   135:     ; The reponse says we are STILL in an IDLE state, which means there is an error
00:CFA0 A229            	   136:     ldx #41 ; command number to print
00:CFA2 2038C6          	   137:     jsr print_spi_cmd_error
                        	   138:     
00:CFA5 4CADCF          	   139:     jmp done_with_initialize_do_not_proceed
                        	   140:     
                        	   141: command55_not_in_idle_state:
                        	   142:     ; The reponse says we are not in an IDLE state, which means there is an error
00:CFA8 A237            	   143:     ldx #55 ; command number to print
00:CFAA 2038C6          	   144:     jsr print_spi_cmd_error
                        	   145:     
                        	   146: done_with_initialize_do_not_proceed:
00:CFAD 20CFC3          	   147:     jsr move_cursor_to_next_line
                        	   148: 
                        	   149:     ; We unselect the card
00:CFB0 A902            	   150:     lda #SPI_CHIP_DESELECT_AND_SLOW
00:CFB2 8D3F9F          	   151:     sta VERA_SPI_CTRL
                        	   152: 
                        	   153:     ; TODO: Can we further 'POWER OFF' the card?
00:CFB5 18              	   154:     clc
00:CFB6 60              	   155:     rts
                        	   156: 
                        	   157: done_with_initialize_proceed:
00:CFB7 20CFC3          	   158:     jsr move_cursor_to_next_line
00:CFBA 38              	   159:     sec
00:CFBB 60              	   160:     rts
                        	   161:     
                        	   162: ; ======= Reset SD Card ========    
                        	   163: 
                        	   164: vera_reset_sd_card:
                        	   165: 
00:CFBC A941            	   166:     lda #COLOR_NORMAL
00:CFBE 8508            	   167:     sta TEXT_COLOR
                        	   168:     
00:CFC0 A9AB            	   169:     lda #<vera_sd_reset_message
00:CFC2 8506            	   170:     sta TEXT_TO_PRINT
00:CFC4 A9CE            	   171:     lda #>vera_sd_reset_message
00:CFC6 8507            	   172:     sta TEXT_TO_PRINT + 1
                        	   173:     
00:CFC8 20ECC3          	   174:     jsr print_text_zero
                        	   175:     
                        	   176: 
                        	   177:     ; === Power ON ===
                        	   178: 
                        	   179:     ; "Set SPI clock rate between 100 kHz and 400 kHz.
                        	   180:     ;  Set DI and CS high and apply 74 or more clock pulses to SCLK"
                        	   181:        
                        	   182:     ; Note that DI is pulled high (in hardware) so we dont have to do anything in software to arrange that.
                        	   183:     ; We deselect (=CS high) the card by setting a bit to 1 in the CTRL register in VERA. The speed of the clock is set
                        	   184:     
00:CFCB A902            	   185:     lda #SPI_CHIP_DESELECT_AND_SLOW
00:CFCD 8D3F9F          	   186:     sta VERA_SPI_CTRL
                        	   187:     
                        	   188:     ; We apply (at least) 74 clock pulses a reading 10 bytes (10 * 8 = 80 clock pulses) from the card
00:CFD0 A20A            	   189:     ldx #10
                        	   190: spi_dummy_clock_loop:
00:CFD2 2032D1          	   191:     jsr spi_read_byte
00:CFD5 CA              	   192:     dex
00:CFD6 D0FA            	   193:     bne spi_dummy_clock_loop
                        	   194:     
                        	   195:     
                        	   196:     ; === Software reset ===
                        	   197:     
                        	   198:     ; "Send a CMD0 with CS low to reset the card. The card samples CS signal on a CMD0 is received successfully. 
                        	   199:     ;  If the CS signal is low, the card enters SPI mode and responds R1 with In Idle State bit set (0x01). 
                        	   200:     ;  Since the CMD0 must be sent as a native command, the CRC field must have a valid value. When once the card 
                        	   201:     ;  enters SPI mode, the CRC feature is disabled and the command CRC and data CRC are not checked by the card, 
                        	   202:     ;  so that command transmission routine can be written with the hardcorded CRC value that valid for only CMD0 
                        	   203:     ;  and CMD8 used in the initialization process."
                        	   204: 
                        	   205:     ; We set CS low (but keep the clock speed slow)
00:CFD8 A903            	   206:     lda #SPI_CHIP_SELECT_AND_SLOW
00:CFDA 8D3F9F          	   207:     sta VERA_SPI_CTRL
                        	   208:     
                        	   209:     ; TODO: do we have to read adter the select?
00:CFDD 2032D1          	   210:     jsr spi_read_byte
00:CFE0 2032D1          	   211:     jsr spi_read_byte
                        	   212:     
                        	   213:     ; We send command 0 to do a software reset
00:CFE3 2080D0          	   214:     jsr spi_send_command0
                        	   215:     
00:CFE6 B012            	   216:     bcs command0_success
                        	   217: command0_timed_out:
                        	   218: 
                        	   219:     ; If carry is unset, we timed out. We print 'No Card Detected' as a warning
00:CFE8 A948            	   220:     lda #COLOR_WARNING
00:CFEA 8508            	   221:     sta TEXT_COLOR
                        	   222:     
00:CFEC A90E            	   223:     lda #<vera_sd_no_card_detected
00:CFEE 8506            	   224:     sta TEXT_TO_PRINT
00:CFF0 A9CF            	   225:     lda #>vera_sd_no_card_detected
00:CFF2 8507            	   226:     sta TEXT_TO_PRINT + 1
                        	   227:     
00:CFF4 20ECC3          	   228:     jsr print_text_zero
                        	   229: 
00:CFF7 4C15D0          	   230:     jmp done_with_command0_do_not_proceed
                        	   231: command0_success:
                        	   232:     ; We got a byte of response. We check if the SD Card is not in an IDLE state (which is expected)
00:CFFA C901            	   233:     cmp #%0000001   ; IDLE state
00:CFFC D012            	   234:     bne command0_not_in_idle_state
                        	   235:     
00:CFFE A945            	   236:     lda #COLOR_OK
00:D000 8508            	   237:     sta TEXT_COLOR
                        	   238:     
00:D002 A9B9            	   239:     lda #<ok_message
00:D004 8506            	   240:     sta TEXT_TO_PRINT
00:D006 A9C3            	   241:     lda #>ok_message
00:D008 8507            	   242:     sta TEXT_TO_PRINT + 1
                        	   243:     
00:D00A 20ECC3          	   244:     jsr print_text_zero
                        	   245:     
00:D00D 4C1FD0          	   246:     jmp done_with_command0_proceed
                        	   247:     
                        	   248: command0_not_in_idle_state:
                        	   249:     ; The reponse says we are not in an IDLE state, which means there is an error
00:D010 A200            	   250:     ldx #0 ; command number to print
00:D012 2038C6          	   251:     jsr print_spi_cmd_error
                        	   252:     
                        	   253: done_with_command0_do_not_proceed:
00:D015 20CFC3          	   254:     jsr move_cursor_to_next_line
                        	   255: 
                        	   256:     ; We unselect the card
00:D018 A902            	   257:     lda #SPI_CHIP_DESELECT_AND_SLOW
00:D01A 8D3F9F          	   258:     sta VERA_SPI_CTRL
                        	   259: 
                        	   260:     ; TODO: Can we further 'POWER OFF' the card?
00:D01D 18              	   261:     clc
00:D01E 60              	   262:     rts
                        	   263: 
                        	   264: done_with_command0_proceed:
00:D01F 20CFC3          	   265:     jsr move_cursor_to_next_line
00:D022 38              	   266:     sec
00:D023 60              	   267:     rts
                        	   268: 
                        	   269: ; ======= Check SDC Ver.2+ ========    
                        	   270: 
                        	   271: vera_check_sdc_version:
                        	   272:     
00:D024 A941            	   273:     lda #COLOR_NORMAL
00:D026 8508            	   274:     sta TEXT_COLOR
                        	   275:     
00:D028 A9D0            	   276:     lda #<vera_check_sdc_version_message
00:D02A 8506            	   277:     sta TEXT_TO_PRINT
00:D02C A9CE            	   278:     lda #>vera_check_sdc_version_message
00:D02E 8507            	   279:     sta TEXT_TO_PRINT + 1
                        	   280:     
00:D030 20ECC3          	   281:     jsr print_text_zero
                        	   282:     
                        	   283:     ; We send command 8 (with $01AA) to check for SDC Ver2.+
00:D033 20ACD0          	   284:     jsr spi_send_command8
                        	   285:     
00:D036 B012            	   286:     bcs command8_success
                        	   287: command8_timed_out:
                        	   288:     
                        	   289:     ; If carry is unset, we timed out. We print 'Timeout' as an error
00:D038 A942            	   290:     lda #COLOR_ERROR
00:D03A 8508            	   291:     sta TEXT_COLOR
                        	   292:     
00:D03C A91F            	   293:     lda #<vera_sd_timeout_message
00:D03E 8506            	   294:     sta TEXT_TO_PRINT
00:D040 A9CF            	   295:     lda #>vera_sd_timeout_message
00:D042 8507            	   296:     sta TEXT_TO_PRINT + 1
                        	   297:     
00:D044 20ECC3          	   298:     jsr print_text_zero
                        	   299: 
00:D047 4C71D0          	   300:     jmp done_with_command8_do_not_proceed
                        	   301:     
                        	   302: command8_success:
                        	   303: 
                        	   304:     ; We got our first byte of response. We check if the SD Card is not in an IDLE state (which is expected)
00:D04A C901            	   305:     cmp #%0000001   ; IDLE state
00:D04C D01E            	   306:     bne command8_not_in_idle_state
                        	   307:     
                        	   308:     ; Retrieve the additional 4 bytes of the R7 response
00:D04E 2032D1          	   309: 	jsr spi_read_byte
00:D051 2032D1          	   310: 	jsr spi_read_byte
00:D054 2032D1          	   311: 	jsr spi_read_byte
00:D057 2032D1          	   312: 	jsr spi_read_byte
                        	   313:     
                        	   314:     ; FIXME: shouldnt we do something with those 4 bytes? (look at schematic)
                        	   315: 
00:D05A A945            	   316:     lda #COLOR_OK
00:D05C 8508            	   317:     sta TEXT_COLOR
                        	   318:     
00:D05E A9B9            	   319:     lda #<ok_message
00:D060 8506            	   320:     sta TEXT_TO_PRINT
00:D062 A9C3            	   321:     lda #>ok_message
00:D064 8507            	   322:     sta TEXT_TO_PRINT + 1
                        	   323:     
00:D066 20ECC3          	   324:     jsr print_text_zero
                        	   325:     
00:D069 4C7BD0          	   326:     jmp done_with_command8_proceed
                        	   327:     
                        	   328: command8_not_in_idle_state:
                        	   329:     ; The reponse says we are not in an IDLE state, which means there is an error
00:D06C A208            	   330:     ldx #8 ; command number to print
00:D06E 2038C6          	   331:     jsr print_spi_cmd_error
                        	   332:     
                        	   333: done_with_command8_do_not_proceed:
00:D071 20CFC3          	   334:     jsr move_cursor_to_next_line
                        	   335: 
                        	   336:     ; We unselect the card
00:D074 A902            	   337:     lda #SPI_CHIP_DESELECT_AND_SLOW
00:D076 8D3F9F          	   338:     sta VERA_SPI_CTRL
                        	   339: 
                        	   340:     ; TODO: Can we further 'POWER OFF' the card?
00:D079 18              	   341:     clc
00:D07A 60              	   342:     rts
                        	   343: 
                        	   344: done_with_command8_proceed:
00:D07B 20CFC3          	   345:     jsr move_cursor_to_next_line
00:D07E 38              	   346:     sec
00:D07F 60              	   347:     rts
                        	   348:     
                        	   349:     
                        	   350: 
                        	   351:     
                        	   352: spi_send_command0:
                        	   353: 
                        	   354:     ; The command index requires the highest bit to be 0 and the bit after that to be 1 = $40
00:D080 A940            	   355:     lda #(0 | $40)      
00:D082 2040D1          	   356:     jsr spi_write_byte
                        	   357:     
                        	   358:     ; Command 0 has no arguments, so sending 4 bytes with value 0
00:D085 A900            	   359:     lda #0
00:D087 2040D1          	   360:     jsr spi_write_byte
00:D08A 2040D1          	   361:     jsr spi_write_byte
00:D08D 2040D1          	   362:     jsr spi_write_byte
00:D090 2040D1          	   363:     jsr spi_write_byte
                        	   364:     
                        	   365:     ; Command 0 requires an CRC. Since everything is fixed for this command, the CRC is already known
00:D093 A995            	   366:     lda #$95            ; CRC for command0
00:D095 2040D1          	   367:     jsr spi_write_byte
                        	   368: 
                        	   369:     ; We wait for a response
00:D098 A214            	   370:     ldx #20                   ; TODO: how many retries do we want to do?
                        	   371: spi_wait_command0:
00:D09A CA              	   372:     dex
00:D09B F00D            	   373:     beq spi_command0_timeout
00:D09D 2032D1          	   374:     jsr spi_read_byte
00:D0A0 A8              	   375:     tay                       ; we want to keep the original value (so we put it in y for now)
                        	   376:     ; FIXME: Use 65C02 processor so we can use "bit #$80" here
00:D0A1 2980            	   377:     and #$80
00:D0A3 C980            	   378:     cmp #$80
00:D0A5 F0F3            	   379:     beq spi_wait_command0
                        	   380:     
00:D0A7 98              	   381:     tya                       ; we restore the original value (stored in y)
                        	   382: 
00:D0A8 38              	   383:     sec  ; set the carry: we succeeded
00:D0A9 60              	   384:     rts
                        	   385: 
                        	   386: spi_command0_timeout:
00:D0AA 18              	   387:     clc  ; clear the carry: we did not succeed
00:D0AB 60              	   388:     rts
                        	   389: 
                        	   390:     
                        	   391:     
                        	   392: spi_send_command8:
                        	   393: 
                        	   394:     ; The command index requires the highest bit to be 0 and the bit after that to be 1 = $40
00:D0AC A948            	   395:     lda #(8 | $40)      
00:D0AE 2040D1          	   396:     jsr spi_write_byte
                        	   397:     
                        	   398:     ; Command 8 has two bytes of argument, so sending two bytes with value 0 and then the 2 bytes as argument ($01AA) 
00:D0B1 A900            	   399:     lda #0
00:D0B3 2040D1          	   400:     jsr spi_write_byte
00:D0B6 2040D1          	   401:     jsr spi_write_byte
                        	   402:     
00:D0B9 A901            	   403:     lda #$01
00:D0BB 2040D1          	   404:     jsr spi_write_byte
00:D0BE A9AA            	   405:     lda #$AA
00:D0C0 2040D1          	   406:     jsr spi_write_byte
                        	   407:     
                        	   408:     ; Command 0 requires an CRC. Since everything is fixed for this command, the CRC is already known
00:D0C3 A987            	   409:     lda #$87            ; CRC for command8
00:D0C5 2040D1          	   410:     jsr spi_write_byte
                        	   411: 
                        	   412:     ; We wait for a response (which should be R1 + 32 bits = R7)
00:D0C8 A214            	   413:     ldx #20                   ; TODO: how many retries do we want to do?
                        	   414: spi_wait_command8:
00:D0CA CA              	   415:     dex
00:D0CB F00D            	   416:     beq spi_command8_timeout
00:D0CD 2032D1          	   417:     jsr spi_read_byte
00:D0D0 A8              	   418:     tay                       ; we want to keep the original value (so we put it in y for now)
                        	   419:     ; FIXME: Use 65C02 processor so we can use "bit #$80" here
00:D0D1 2980            	   420:     and #$80
00:D0D3 C980            	   421:     cmp #$80
00:D0D5 F0F3            	   422:     beq spi_wait_command8
                        	   423:     
00:D0D7 98              	   424:     tya                       ; we restore the original value (stored in y)
                        	   425: 
00:D0D8 38              	   426:     sec  ; set the carry: we succeeded
00:D0D9 60              	   427:     rts
                        	   428: 
                        	   429: spi_command8_timeout:
00:D0DA 18              	   430:     clc  ; clear the carry: we did not succeed
00:D0DB 60              	   431:     rts
                        	   432: 
                        	   433: 
                        	   434: 
                        	   435: spi_send_command55:
                        	   436: 
                        	   437:     ; The command index requires the highest bit to be 0 and the bit after that to be 1 = $40
00:D0DC A977            	   438:     lda #(55 | $40)      
00:D0DE 2040D1          	   439:     jsr spi_write_byte
                        	   440:     
                        	   441:     ; Command 55 has no arguments, so sending 4 bytes with value 0
00:D0E1 A900            	   442:     lda #0
00:D0E3 2040D1          	   443:     jsr spi_write_byte
00:D0E6 2040D1          	   444:     jsr spi_write_byte
00:D0E9 2040D1          	   445:     jsr spi_write_byte
00:D0EC 2040D1          	   446:     jsr spi_write_byte
                        	   447:     
                        	   448:     ; Command 0 requires no CRC. So we send another 0
00:D0EF 2040D1          	   449:     jsr spi_write_byte
                        	   450: 
                        	   451:     ; We wait for a response
00:D0F2 A214            	   452:     ldx #20                   ; TODO: how many retries do we want to do?
                        	   453: spi_wait_command55:
00:D0F4 CA              	   454:     dex
00:D0F5 F00D            	   455:     beq spi_command55_timeout
00:D0F7 2032D1          	   456:     jsr spi_read_byte
00:D0FA A8              	   457:     tay                       ; we want to keep the original value (so we put it in y for now)
                        	   458:     ; FIXME: Use 65C02 processor so we can use "bit #$80" here
00:D0FB 2980            	   459:     and #$80
00:D0FD C980            	   460:     cmp #$80
00:D0FF F0F3            	   461:     beq spi_wait_command55
                        	   462:     
00:D101 98              	   463:     tya                       ; we restore the original value (stored in y)
                        	   464: 
00:D102 38              	   465:     sec  ; set the carry: we succeeded
00:D103 60              	   466:     rts
                        	   467: 
                        	   468: spi_command55_timeout:
00:D104 18              	   469:     clc  ; clear the carry: we did not succeed
00:D105 60              	   470:     rts
                        	   471: 
                        	   472:     
                        	   473:     
                        	   474: spi_send_command41:
                        	   475: 
                        	   476:     ; The command index requires the highest bit to be 0 and the bit after that to be 1 = $40
00:D106 A969            	   477:     lda #(41 | $40)      
00:D108 2040D1          	   478:     jsr spi_write_byte
                        	   479:     
                        	   480:     ; Command 41 has four bytes of argument ($40000000) 
00:D10B A940            	   481:     lda #$40
00:D10D 2040D1          	   482:     jsr spi_write_byte
00:D110 A900            	   483:     lda #0
00:D112 2040D1          	   484:     jsr spi_write_byte
00:D115 2040D1          	   485:     jsr spi_write_byte
00:D118 2040D1          	   486:     jsr spi_write_byte
                        	   487:     
                        	   488:     ; Command 41 requires no CRC. So sending another 0
00:D11B 2040D1          	   489:     jsr spi_write_byte
                        	   490: 
                        	   491:     ; We wait for a response
00:D11E A214            	   492:     ldx #20                   ; TODO: how many retries do we want to do?
                        	   493: spi_wait_command41:
00:D120 CA              	   494:     dex
00:D121 F00D            	   495:     beq spi_command41_timeout
00:D123 2032D1          	   496:     jsr spi_read_byte
00:D126 A8              	   497:     tay                       ; we want to keep the original value (so we put it in y for now)
                        	   498:     ; FIXME: Use 65C02 processor so we can use "bit #$80" here
00:D127 2980            	   499:     and #$80
00:D129 C980            	   500:     cmp #$80
00:D12B F0F3            	   501:     beq spi_wait_command41
                        	   502:     
00:D12D 98              	   503:     tya                       ; we restore the original value (stored in y)
                        	   504: 
00:D12E 38              	   505:     sec  ; set the carry: we succeeded
00:D12F 60              	   506:     rts
                        	   507: 
                        	   508: spi_command41_timeout:
00:D130 18              	   509:     clc  ; clear the carry: we did not succeed
00:D131 60              	   510:     rts
                        	   511: 
                        	   512:     
                        	   513: 
                        	   514: 
                        	   515: spi_read_byte:
                        	   516: 
                        	   517:     ; "Because the data transfer is driven by serial clock generated by host controller, the host controller 
                        	   518:     ;  must continue to read data, send a 0xFF and get received byte, until a valid response is detected. 
                        	   519:     ;  The DI signal must be kept high during read transfer (send a 0xFF and get the received data). 
                        	   520:     ;  The response is sent back within command response time (NCR), 0 to 8 bytes for SDC, 1 to 8 bytes for MMC."
                        	   521:      
                        	   522:     ; Send 1s (=FF) to the card (MOSI), while keeping the clock running
00:D132 A9FF            	   523:     lda #$FF
00:D134 8D3E9F          	   524:     sta VERA_SPI_DATA
                        	   525:     
                        	   526:     ; VERA is sending the data using SPI to the SD card. This takes some time. We wait until VERA says it has done the 
                        	   527: wait_spi_read_busy:
00:D137 2C3F9F          	   528:     bit VERA_SPI_CTRL
00:D13A 30FB            	   529:     bmi wait_spi_read_busy
                        	   530:     
                        	   531:     ; Read the byte of data VERA got back from the card
00:D13C AD3E9F          	   532:     lda VERA_SPI_DATA
00:D13F 60              	   533:     rts
                        	   534: 
                        	   535: 
                        	   536:     ; Data in register a will be written using SPI to the SD card (through VERA registers)
                        	   537: spi_write_byte:
00:D140 8D3E9F          	   538:     sta VERA_SPI_DATA
                        	   539:     
                        	   540:     ; VERA is sending the data using SPI to the SD card. This takes some time. We wait until VERA says it has done the 
                        	   541: wait_spi_write_busy:
00:D143 2C3F9F          	   542:     bit VERA_SPI_CTRL
00:D146 30FB            	   543:     bmi wait_spi_write_busy  ; if bit 7 is high (Busy bit) we keep waiting
                        	   544:     
00:D148 60              	   545:     rts
                        	   546: 
                        	   547: 

Source: "x16_hardware_tester.s"
                        	   147:   
                        	   148:     ; ======== PETSCII CHARSET =======
                        	   149: 
                        	   150:     .org $F700
                        	   151:     .include "utils/petscii.s"

Source: "utils\petscii.s"
                        	     1: ; This petscii charset is extracted from the x16-rom repository:
                        	     2: ;   https://github.com/commanderx16/x16-rom
                        	     3: 
                        	     4: petscii_0:
01:F700 3C              	     5:     .byte $3C,$66,$6E,$6E,$60,$62,$3C,$00 ; 0
01:F701 66
01:F702 6E
01:F703 6E
01:F704 60
01:F705 62
01:F706 3C
01:F707 00
01:F708 18              	     6:     .byte $18,$3C,$66,$7E,$66,$66,$66,$00 ; 1
01:F709 3C
01:F70A 66
01:F70B 7E
01:F70C 66
01:F70D 66
01:F70E 66
01:F70F 00
01:F710 7C              	     7:     .byte $7C,$66,$66,$7C,$66,$66,$7C,$00 ; 2
01:F711 66
01:F712 66
01:F713 7C
01:F714 66
01:F715 66
01:F716 7C
01:F717 00
01:F718 3C              	     8:     .byte $3C,$66,$60,$60,$60,$66,$3C,$00 ; 3
01:F719 66
01:F71A 60
01:F71B 60
01:F71C 60
01:F71D 66
01:F71E 3C
01:F71F 00
01:F720 78              	     9:     .byte $78,$6C,$66,$66,$66,$6C,$78,$00 ; 4
01:F721 6C
01:F722 66
01:F723 66
01:F724 66
01:F725 6C
01:F726 78
01:F727 00
01:F728 7E              	    10:     .byte $7E,$60,$60,$78,$60,$60,$7E,$00 ; 5
01:F729 60
01:F72A 60
01:F72B 78
01:F72C 60
01:F72D 60
01:F72E 7E
01:F72F 00
01:F730 7E              	    11:     .byte $7E,$60,$60,$78,$60,$60,$60,$00 ; 6
01:F731 60
01:F732 60
01:F733 78
01:F734 60
01:F735 60
01:F736 60
01:F737 00
01:F738 3C              	    12:     .byte $3C,$66,$60,$6E,$66,$66,$3C,$00 ; 7
01:F739 66
01:F73A 60
01:F73B 6E
01:F73C 66
01:F73D 66
01:F73E 3C
01:F73F 00
01:F740 66              	    13:     .byte $66,$66,$66,$7E,$66,$66,$66,$00 ; 8
01:F741 66
01:F742 66
01:F743 7E
01:F744 66
01:F745 66
01:F746 66
01:F747 00
01:F748 3C              	    14:     .byte $3C,$18,$18,$18,$18,$18,$3C,$00 ; 9
01:F749 18
01:F74A 18
01:F74B 18
01:F74C 18
01:F74D 18
01:F74E 3C
01:F74F 00
01:F750 1E              	    15:     .byte $1E,$0C,$0C,$0C,$0C,$6C,$38,$00 ; 10
01:F751 0C
01:F752 0C
01:F753 0C
01:F754 0C
01:F755 6C
01:F756 38
01:F757 00
01:F758 66              	    16:     .byte $66,$6C,$78,$70,$78,$6C,$66,$00 ; 11
01:F759 6C
01:F75A 78
01:F75B 70
01:F75C 78
01:F75D 6C
01:F75E 66
01:F75F 00
01:F760 60              	    17:     .byte $60,$60,$60,$60,$60,$60,$7E,$00 ; 12
01:F761 60
01:F762 60
01:F763 60
01:F764 60
01:F765 60
01:F766 7E
01:F767 00
01:F768 63              	    18:     .byte $63,$77,$7F,$6B,$63,$63,$63,$00 ; 13
01:F769 77
01:F76A 7F
01:F76B 6B
01:F76C 63
01:F76D 63
01:F76E 63
01:F76F 00
01:F770 66              	    19:     .byte $66,$76,$7E,$7E,$6E,$66,$66,$00 ; 14
01:F771 76
01:F772 7E
01:F773 7E
01:F774 6E
01:F775 66
01:F776 66
01:F777 00
01:F778 3C              	    20:     .byte $3C,$66,$66,$66,$66,$66,$3C,$00 ; 15
01:F779 66
01:F77A 66
01:F77B 66
01:F77C 66
01:F77D 66
01:F77E 3C
01:F77F 00
01:F780 7C              	    21:     .byte $7C,$66,$66,$7C,$60,$60,$60,$00 ; 16
01:F781 66
01:F782 66
01:F783 7C
01:F784 60
01:F785 60
01:F786 60
01:F787 00
01:F788 3C              	    22:     .byte $3C,$66,$66,$66,$66,$3C,$0E,$00 ; 17
01:F789 66
01:F78A 66
01:F78B 66
01:F78C 66
01:F78D 3C
01:F78E 0E
01:F78F 00
01:F790 7C              	    23:     .byte $7C,$66,$66,$7C,$78,$6C,$66,$00 ; 18
01:F791 66
01:F792 66
01:F793 7C
01:F794 78
01:F795 6C
01:F796 66
01:F797 00
01:F798 3C              	    24:     .byte $3C,$66,$60,$3C,$06,$66,$3C,$00 ; 19
01:F799 66
01:F79A 60
01:F79B 3C
01:F79C 06
01:F79D 66
01:F79E 3C
01:F79F 00
01:F7A0 7E              	    25:     .byte $7E,$18,$18,$18,$18,$18,$18,$00 ; 20
01:F7A1 18
01:F7A2 18
01:F7A3 18
01:F7A4 18
01:F7A5 18
01:F7A6 18
01:F7A7 00
01:F7A8 66              	    26:     .byte $66,$66,$66,$66,$66,$66,$3C,$00 ; 21
01:F7A9 66
01:F7AA 66
01:F7AB 66
01:F7AC 66
01:F7AD 66
01:F7AE 3C
01:F7AF 00
01:F7B0 66              	    27:     .byte $66,$66,$66,$66,$66,$3C,$18,$00 ; 22
01:F7B1 66
01:F7B2 66
01:F7B3 66
01:F7B4 66
01:F7B5 3C
01:F7B6 18
01:F7B7 00
01:F7B8 63              	    28:     .byte $63,$63,$63,$6B,$7F,$77,$63,$00 ; 23
01:F7B9 63
01:F7BA 63
01:F7BB 6B
01:F7BC 7F
01:F7BD 77
01:F7BE 63
01:F7BF 00
01:F7C0 66              	    29:     .byte $66,$66,$3C,$18,$3C,$66,$66,$00 ; 24
01:F7C1 66
01:F7C2 3C
01:F7C3 18
01:F7C4 3C
01:F7C5 66
01:F7C6 66
01:F7C7 00
01:F7C8 66              	    30:     .byte $66,$66,$66,$3C,$18,$18,$18,$00 ; 25
01:F7C9 66
01:F7CA 66
01:F7CB 3C
01:F7CC 18
01:F7CD 18
01:F7CE 18
01:F7CF 00
01:F7D0 7E              	    31:     .byte $7E,$06,$0C,$18,$30,$60,$7E,$00 ; 26
01:F7D1 06
01:F7D2 0C
01:F7D3 18
01:F7D4 30
01:F7D5 60
01:F7D6 7E
01:F7D7 00
01:F7D8 3C              	    32:     .byte $3C,$30,$30,$30,$30,$30,$3C,$00 ; 27
01:F7D9 30
01:F7DA 30
01:F7DB 30
01:F7DC 30
01:F7DD 30
01:F7DE 3C
01:F7DF 00
01:F7E0 0C              	    33:     .byte $0C,$12,$30,$7C,$30,$62,$FC,$00 ; 28
01:F7E1 12
01:F7E2 30
01:F7E3 7C
01:F7E4 30
01:F7E5 62
01:F7E6 FC
01:F7E7 00
01:F7E8 3C              	    34:     .byte $3C,$0C,$0C,$0C,$0C,$0C,$3C,$00 ; 29
01:F7E9 0C
01:F7EA 0C
01:F7EB 0C
01:F7EC 0C
01:F7ED 0C
01:F7EE 3C
01:F7EF 00
01:F7F0 00              	    35:     .byte $00,$18,$3C,$7E,$18,$18,$18,$18 ; 30
01:F7F1 18
01:F7F2 3C
01:F7F3 7E
01:F7F4 18
01:F7F5 18
01:F7F6 18
01:F7F7 18
01:F7F8 00              	    36:     .byte $00,$10,$30,$7F,$7F,$30,$10,$00 ; 31
01:F7F9 10
01:F7FA 30
01:F7FB 7F
01:F7FC 7F
01:F7FD 30
01:F7FE 10
01:F7FF 00
                        	    37: petscii_1:
01:F800 00              	    38:     .byte $00,$00,$00,$00,$00,$00,$00,$00 ; 32
01:F801 00
01:F802 00
01:F803 00
01:F804 00
01:F805 00
01:F806 00
01:F807 00
01:F808 18              	    39:     .byte $18,$18,$18,$18,$00,$00,$18,$00 ; 33
01:F809 18
01:F80A 18
01:F80B 18
01:F80C 00
01:F80D 00
01:F80E 18
01:F80F 00
01:F810 66              	    40:     .byte $66,$66,$66,$00,$00,$00,$00,$00 ; 34
01:F811 66
01:F812 66
01:F813 00
01:F814 00
01:F815 00
01:F816 00
01:F817 00
01:F818 66              	    41:     .byte $66,$66,$FF,$66,$FF,$66,$66,$00 ; 35
01:F819 66
01:F81A FF
01:F81B 66
01:F81C FF
01:F81D 66
01:F81E 66
01:F81F 00
01:F820 18              	    42:     .byte $18,$3E,$60,$3C,$06,$7C,$18,$00 ; 36
01:F821 3E
01:F822 60
01:F823 3C
01:F824 06
01:F825 7C
01:F826 18
01:F827 00
01:F828 62              	    43:     .byte $62,$66,$0C,$18,$30,$66,$46,$00 ; 37
01:F829 66
01:F82A 0C
01:F82B 18
01:F82C 30
01:F82D 66
01:F82E 46
01:F82F 00
01:F830 3C              	    44:     .byte $3C,$66,$3C,$38,$67,$66,$3F,$00 ; 38
01:F831 66
01:F832 3C
01:F833 38
01:F834 67
01:F835 66
01:F836 3F
01:F837 00
01:F838 06              	    45:     .byte $06,$0C,$18,$00,$00,$00,$00,$00 ; 39
01:F839 0C
01:F83A 18
01:F83B 00
01:F83C 00
01:F83D 00
01:F83E 00
01:F83F 00
01:F840 0C              	    46:     .byte $0C,$18,$30,$30,$30,$18,$0C,$00 ; 40
01:F841 18
01:F842 30
01:F843 30
01:F844 30
01:F845 18
01:F846 0C
01:F847 00
01:F848 30              	    47:     .byte $30,$18,$0C,$0C,$0C,$18,$30,$00 ; 41
01:F849 18
01:F84A 0C
01:F84B 0C
01:F84C 0C
01:F84D 18
01:F84E 30
01:F84F 00
01:F850 00              	    48:     .byte $00,$66,$3C,$FF,$3C,$66,$00,$00 ; 42
01:F851 66
01:F852 3C
01:F853 FF
01:F854 3C
01:F855 66
01:F856 00
01:F857 00
01:F858 00              	    49:     .byte $00,$18,$18,$7E,$18,$18,$00,$00 ; 43
01:F859 18
01:F85A 18
01:F85B 7E
01:F85C 18
01:F85D 18
01:F85E 00
01:F85F 00
01:F860 00              	    50:     .byte $00,$00,$00,$00,$00,$18,$18,$30 ; 44
01:F861 00
01:F862 00
01:F863 00
01:F864 00
01:F865 18
01:F866 18
01:F867 30
01:F868 00              	    51:     .byte $00,$00,$00,$7E,$00,$00,$00,$00 ; 45
01:F869 00
01:F86A 00
01:F86B 7E
01:F86C 00
01:F86D 00
01:F86E 00
01:F86F 00
01:F870 00              	    52:     .byte $00,$00,$00,$00,$00,$18,$18,$00 ; 46
01:F871 00
01:F872 00
01:F873 00
01:F874 00
01:F875 18
01:F876 18
01:F877 00
01:F878 00              	    53:     .byte $00,$03,$06,$0C,$18,$30,$60,$00 ; 47
01:F879 03
01:F87A 06
01:F87B 0C
01:F87C 18
01:F87D 30
01:F87E 60
01:F87F 00
01:F880 3C              	    54:     .byte $3C,$66,$6E,$76,$66,$66,$3C,$00 ; 48
01:F881 66
01:F882 6E
01:F883 76
01:F884 66
01:F885 66
01:F886 3C
01:F887 00
01:F888 18              	    55:     .byte $18,$18,$38,$18,$18,$18,$7E,$00 ; 49
01:F889 18
01:F88A 38
01:F88B 18
01:F88C 18
01:F88D 18
01:F88E 7E
01:F88F 00
01:F890 3C              	    56:     .byte $3C,$66,$06,$0C,$30,$60,$7E,$00 ; 50
01:F891 66
01:F892 06
01:F893 0C
01:F894 30
01:F895 60
01:F896 7E
01:F897 00
01:F898 3C              	    57:     .byte $3C,$66,$06,$1C,$06,$66,$3C,$00 ; 51
01:F899 66
01:F89A 06
01:F89B 1C
01:F89C 06
01:F89D 66
01:F89E 3C
01:F89F 00
01:F8A0 06              	    58:     .byte $06,$0E,$1E,$66,$7F,$06,$06,$00 ; 52
01:F8A1 0E
01:F8A2 1E
01:F8A3 66
01:F8A4 7F
01:F8A5 06
01:F8A6 06
01:F8A7 00
01:F8A8 7E              	    59:     .byte $7E,$60,$7C,$06,$06,$66,$3C,$00 ; 53
01:F8A9 60
01:F8AA 7C
01:F8AB 06
01:F8AC 06
01:F8AD 66
01:F8AE 3C
01:F8AF 00
01:F8B0 3C              	    60:     .byte $3C,$66,$60,$7C,$66,$66,$3C,$00 ; 54
01:F8B1 66
01:F8B2 60
01:F8B3 7C
01:F8B4 66
01:F8B5 66
01:F8B6 3C
01:F8B7 00
01:F8B8 7E              	    61:     .byte $7E,$66,$0C,$18,$18,$18,$18,$00 ; 55
01:F8B9 66
01:F8BA 0C
01:F8BB 18
01:F8BC 18
01:F8BD 18
01:F8BE 18
01:F8BF 00
01:F8C0 3C              	    62:     .byte $3C,$66,$66,$3C,$66,$66,$3C,$00 ; 56
01:F8C1 66
01:F8C2 66
01:F8C3 3C
01:F8C4 66
01:F8C5 66
01:F8C6 3C
01:F8C7 00
01:F8C8 3C              	    63:     .byte $3C,$66,$66,$3E,$06,$66,$3C,$00 ; 57
01:F8C9 66
01:F8CA 66
01:F8CB 3E
01:F8CC 06
01:F8CD 66
01:F8CE 3C
01:F8CF 00
01:F8D0 00              	    64:     .byte $00,$00,$18,$00,$00,$18,$00,$00 ; 58
01:F8D1 00
01:F8D2 18
01:F8D3 00
01:F8D4 00
01:F8D5 18
01:F8D6 00
01:F8D7 00
01:F8D8 00              	    65:     .byte $00,$00,$18,$00,$00,$18,$18,$30 ; 59
01:F8D9 00
01:F8DA 18
01:F8DB 00
01:F8DC 00
01:F8DD 18
01:F8DE 18
01:F8DF 30
01:F8E0 0E              	    66:     .byte $0E,$18,$30,$60,$30,$18,$0E,$00 ; 60
01:F8E1 18
01:F8E2 30
01:F8E3 60
01:F8E4 30
01:F8E5 18
01:F8E6 0E
01:F8E7 00
01:F8E8 00              	    67:     .byte $00,$00,$7E,$00,$7E,$00,$00,$00 ; 61
01:F8E9 00
01:F8EA 7E
01:F8EB 00
01:F8EC 7E
01:F8ED 00
01:F8EE 00
01:F8EF 00
01:F8F0 70              	    68:     .byte $70,$18,$0C,$06,$0C,$18,$70,$00 ; 62
01:F8F1 18
01:F8F2 0C
01:F8F3 06
01:F8F4 0C
01:F8F5 18
01:F8F6 70
01:F8F7 00
01:F8F8 3C              	    69:     .byte $3C,$66,$06,$0C,$18,$00,$18,$00 ; 63
01:F8F9 66
01:F8FA 06
01:F8FB 0C
01:F8FC 18
01:F8FD 00
01:F8FE 18
01:F8FF 00
                        	    70: petscii_2:
01:F900 00              	    71:     .byte $00,$00,$00,$FF,$FF,$00,$00,$00 ; 64
01:F901 00
01:F902 00
01:F903 FF
01:F904 FF
01:F905 00
01:F906 00
01:F907 00
01:F908 08              	    72:     .byte $08,$1C,$3E,$7F,$7F,$1C,$3E,$00 ; 65
01:F909 1C
01:F90A 3E
01:F90B 7F
01:F90C 7F
01:F90D 1C
01:F90E 3E
01:F90F 00
01:F910 18              	    73:     .byte $18,$18,$18,$18,$18,$18,$18,$18 ; 66
01:F911 18
01:F912 18
01:F913 18
01:F914 18
01:F915 18
01:F916 18
01:F917 18
01:F918 00              	    74:     .byte $00,$00,$00,$FF,$FF,$00,$00,$00 ; 67
01:F919 00
01:F91A 00
01:F91B FF
01:F91C FF
01:F91D 00
01:F91E 00
01:F91F 00
01:F920 00              	    75:     .byte $00,$00,$FF,$FF,$00,$00,$00,$00 ; 68
01:F921 00
01:F922 FF
01:F923 FF
01:F924 00
01:F925 00
01:F926 00
01:F927 00
01:F928 00              	    76:     .byte $00,$FF,$FF,$00,$00,$00,$00,$00 ; 69
01:F929 FF
01:F92A FF
01:F92B 00
01:F92C 00
01:F92D 00
01:F92E 00
01:F92F 00
01:F930 00              	    77:     .byte $00,$00,$00,$00,$FF,$FF,$00,$00 ; 70
01:F931 00
01:F932 00
01:F933 00
01:F934 FF
01:F935 FF
01:F936 00
01:F937 00
01:F938 30              	    78:     .byte $30,$30,$30,$30,$30,$30,$30,$30 ; 71
01:F939 30
01:F93A 30
01:F93B 30
01:F93C 30
01:F93D 30
01:F93E 30
01:F93F 30
01:F940 0C              	    79:     .byte $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C ; 72
01:F941 0C
01:F942 0C
01:F943 0C
01:F944 0C
01:F945 0C
01:F946 0C
01:F947 0C
01:F948 00              	    80:     .byte $00,$00,$00,$E0,$F0,$38,$18,$18 ; 73
01:F949 00
01:F94A 00
01:F94B E0
01:F94C F0
01:F94D 38
01:F94E 18
01:F94F 18
01:F950 18              	    81:     .byte $18,$18,$1C,$0F,$07,$00,$00,$00 ; 74
01:F951 18
01:F952 1C
01:F953 0F
01:F954 07
01:F955 00
01:F956 00
01:F957 00
01:F958 18              	    82:     .byte $18,$18,$38,$F0,$E0,$00,$00,$00 ; 75
01:F959 18
01:F95A 38
01:F95B F0
01:F95C E0
01:F95D 00
01:F95E 00
01:F95F 00
01:F960 C0              	    83:     .byte $C0,$C0,$C0,$C0,$C0,$C0,$FF,$FF ; 76
01:F961 C0
01:F962 C0
01:F963 C0
01:F964 C0
01:F965 C0
01:F966 FF
01:F967 FF
01:F968 C0              	    84:     .byte $C0,$E0,$70,$38,$1C,$0E,$07,$03 ; 77
01:F969 E0
01:F96A 70
01:F96B 38
01:F96C 1C
01:F96D 0E
01:F96E 07
01:F96F 03
01:F970 03              	    85:     .byte $03,$07,$0E,$1C,$38,$70,$E0,$C0 ; 78
01:F971 07
01:F972 0E
01:F973 1C
01:F974 38
01:F975 70
01:F976 E0
01:F977 C0
01:F978 FF              	    86:     .byte $FF,$FF,$C0,$C0,$C0,$C0,$C0,$C0 ; 79
01:F979 FF
01:F97A C0
01:F97B C0
01:F97C C0
01:F97D C0
01:F97E C0
01:F97F C0
01:F980 FF              	    87:     .byte $FF,$FF,$03,$03,$03,$03,$03,$03 ; 80
01:F981 FF
01:F982 03
01:F983 03
01:F984 03
01:F985 03
01:F986 03
01:F987 03
01:F988 00              	    88:     .byte $00,$3C,$7E,$7E,$7E,$7E,$3C,$00 ; 81
01:F989 3C
01:F98A 7E
01:F98B 7E
01:F98C 7E
01:F98D 7E
01:F98E 3C
01:F98F 00
01:F990 00              	    89:     .byte $00,$00,$00,$00,$00,$FF,$FF,$00 ; 82
01:F991 00
01:F992 00
01:F993 00
01:F994 00
01:F995 FF
01:F996 FF
01:F997 00
01:F998 36              	    90:     .byte $36,$7F,$7F,$7F,$3E,$1C,$08,$00 ; 83
01:F999 7F
01:F99A 7F
01:F99B 7F
01:F99C 3E
01:F99D 1C
01:F99E 08
01:F99F 00
01:F9A0 60              	    91:     .byte $60,$60,$60,$60,$60,$60,$60,$60 ; 84
01:F9A1 60
01:F9A2 60
01:F9A3 60
01:F9A4 60
01:F9A5 60
01:F9A6 60
01:F9A7 60
01:F9A8 00              	    92:     .byte $00,$00,$00,$07,$0F,$1C,$18,$18 ; 85
01:F9A9 00
01:F9AA 00
01:F9AB 07
01:F9AC 0F
01:F9AD 1C
01:F9AE 18
01:F9AF 18
01:F9B0 C3              	    93:     .byte $C3,$E7,$7E,$3C,$3C,$7E,$E7,$C3 ; 86
01:F9B1 E7
01:F9B2 7E
01:F9B3 3C
01:F9B4 3C
01:F9B5 7E
01:F9B6 E7
01:F9B7 C3
01:F9B8 00              	    94:     .byte $00,$3C,$7E,$66,$66,$7E,$3C,$00 ; 87
01:F9B9 3C
01:F9BA 7E
01:F9BB 66
01:F9BC 66
01:F9BD 7E
01:F9BE 3C
01:F9BF 00
01:F9C0 18              	    95:     .byte $18,$18,$66,$66,$18,$18,$3C,$00 ; 88
01:F9C1 18
01:F9C2 66
01:F9C3 66
01:F9C4 18
01:F9C5 18
01:F9C6 3C
01:F9C7 00
01:F9C8 06              	    96:     .byte $06,$06,$06,$06,$06,$06,$06,$06 ; 89
01:F9C9 06
01:F9CA 06
01:F9CB 06
01:F9CC 06
01:F9CD 06
01:F9CE 06
01:F9CF 06
01:F9D0 08              	    97:     .byte $08,$1C,$3E,$7F,$3E,$1C,$08,$00 ; 90
01:F9D1 1C
01:F9D2 3E
01:F9D3 7F
01:F9D4 3E
01:F9D5 1C
01:F9D6 08
01:F9D7 00
01:F9D8 18              	    98:     .byte $18,$18,$18,$FF,$FF,$18,$18,$18 ; 91
01:F9D9 18
01:F9DA 18
01:F9DB FF
01:F9DC FF
01:F9DD 18
01:F9DE 18
01:F9DF 18
01:F9E0 C0              	    99:     .byte $C0,$C0,$30,$30,$C0,$C0,$30,$30 ; 92
01:F9E1 C0
01:F9E2 30
01:F9E3 30
01:F9E4 C0
01:F9E5 C0
01:F9E6 30
01:F9E7 30
01:F9E8 18              	   100:     .byte $18,$18,$18,$18,$18,$18,$18,$18 ; 93
01:F9E9 18
01:F9EA 18
01:F9EB 18
01:F9EC 18
01:F9ED 18
01:F9EE 18
01:F9EF 18
01:F9F0 00              	   101:     .byte $00,$00,$03,$3E,$76,$36,$36,$00 ; 94
01:F9F1 00
01:F9F2 03
01:F9F3 3E
01:F9F4 76
01:F9F5 36
01:F9F6 36
01:F9F7 00
01:F9F8 FF              	   102:     .byte $FF,$7F,$3F,$1F,$0F,$07,$03,$01 ; 95
01:F9F9 7F
01:F9FA 3F
01:F9FB 1F
01:F9FC 0F
01:F9FD 07
01:F9FE 03
01:F9FF 01
                        	   103: petscii_3:
01:FA00 00              	   104:     .byte $00,$00,$00,$00,$00,$00,$00,$00 ; 96
01:FA01 00
01:FA02 00
01:FA03 00
01:FA04 00
01:FA05 00
01:FA06 00
01:FA07 00
01:FA08 F0              	   105:     .byte $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; 97
01:FA09 F0
01:FA0A F0
01:FA0B F0
01:FA0C F0
01:FA0D F0
01:FA0E F0
01:FA0F F0
01:FA10 00              	   106:     .byte $00,$00,$00,$00,$FF,$FF,$FF,$FF ; 98
01:FA11 00
01:FA12 00
01:FA13 00
01:FA14 FF
01:FA15 FF
01:FA16 FF
01:FA17 FF
01:FA18 FF              	   107:     .byte $FF,$00,$00,$00,$00,$00,$00,$00 ; 99
01:FA19 00
01:FA1A 00
01:FA1B 00
01:FA1C 00
01:FA1D 00
01:FA1E 00
01:FA1F 00
01:FA20 00              	   108:     .byte $00,$00,$00,$00,$00,$00,$00,$FF ; 100
01:FA21 00
01:FA22 00
01:FA23 00
01:FA24 00
01:FA25 00
01:FA26 00
01:FA27 FF
01:FA28 80              	   109:     .byte $80,$80,$80,$80,$80,$80,$80,$80 ; 101
01:FA29 80
01:FA2A 80
01:FA2B 80
01:FA2C 80
01:FA2D 80
01:FA2E 80
01:FA2F 80
01:FA30 CC              	   110:     .byte $CC,$CC,$33,$33,$CC,$CC,$33,$33 ; 102
01:FA31 CC
01:FA32 33
01:FA33 33
01:FA34 CC
01:FA35 CC
01:FA36 33
01:FA37 33
01:FA38 01              	   111:     .byte $01,$01,$01,$01,$01,$01,$01,$01 ; 103
01:FA39 01
01:FA3A 01
01:FA3B 01
01:FA3C 01
01:FA3D 01
01:FA3E 01
01:FA3F 01
01:FA40 00              	   112:     .byte $00,$00,$00,$00,$CC,$CC,$33,$33 ; 104
01:FA41 00
01:FA42 00
01:FA43 00
01:FA44 CC
01:FA45 CC
01:FA46 33
01:FA47 33
01:FA48 FF              	   113:     .byte $FF,$FE,$FC,$F8,$F0,$E0,$C0,$80 ; 105
01:FA49 FE
01:FA4A FC
01:FA4B F8
01:FA4C F0
01:FA4D E0
01:FA4E C0
01:FA4F 80
01:FA50 03              	   114:     .byte $03,$03,$03,$03,$03,$03,$03,$03 ; 106
01:FA51 03
01:FA52 03
01:FA53 03
01:FA54 03
01:FA55 03
01:FA56 03
01:FA57 03
01:FA58 18              	   115:     .byte $18,$18,$18,$1F,$1F,$18,$18,$18 ; 107
01:FA59 18
01:FA5A 18
01:FA5B 1F
01:FA5C 1F
01:FA5D 18
01:FA5E 18
01:FA5F 18
01:FA60 00              	   116:     .byte $00,$00,$00,$00,$0F,$0F,$0F,$0F ; 108
01:FA61 00
01:FA62 00
01:FA63 00
01:FA64 0F
01:FA65 0F
01:FA66 0F
01:FA67 0F
01:FA68 18              	   117:     .byte $18,$18,$18,$1F,$1F,$00,$00,$00 ; 109
01:FA69 18
01:FA6A 18
01:FA6B 1F
01:FA6C 1F
01:FA6D 00
01:FA6E 00
01:FA6F 00
01:FA70 00              	   118:     .byte $00,$00,$00,$F8,$F8,$18,$18,$18 ; 110
01:FA71 00
01:FA72 00
01:FA73 F8
01:FA74 F8
01:FA75 18
01:FA76 18
01:FA77 18
01:FA78 00              	   119:     .byte $00,$00,$00,$00,$00,$00,$FF,$FF ; 111
01:FA79 00
01:FA7A 00
01:FA7B 00
01:FA7C 00
01:FA7D 00
01:FA7E FF
01:FA7F FF
01:FA80 00              	   120:     .byte $00,$00,$00,$1F,$1F,$18,$18,$18 ; 112
01:FA81 00
01:FA82 00
01:FA83 1F
01:FA84 1F
01:FA85 18
01:FA86 18
01:FA87 18
01:FA88 18              	   121:     .byte $18,$18,$18,$FF,$FF,$00,$00,$00 ; 113
01:FA89 18
01:FA8A 18
01:FA8B FF
01:FA8C FF
01:FA8D 00
01:FA8E 00
01:FA8F 00
01:FA90 00              	   122:     .byte $00,$00,$00,$FF,$FF,$18,$18,$18 ; 114
01:FA91 00
01:FA92 00
01:FA93 FF
01:FA94 FF
01:FA95 18
01:FA96 18
01:FA97 18
01:FA98 18              	   123:     .byte $18,$18,$18,$F8,$F8,$18,$18,$18 ; 115
01:FA99 18
01:FA9A 18
01:FA9B F8
01:FA9C F8
01:FA9D 18
01:FA9E 18
01:FA9F 18
01:FAA0 C0              	   124:     .byte $C0,$C0,$C0,$C0,$C0,$C0,$C0,$C0 ; 116
01:FAA1 C0
01:FAA2 C0
01:FAA3 C0
01:FAA4 C0
01:FAA5 C0
01:FAA6 C0
01:FAA7 C0
01:FAA8 E0              	   125:     .byte $E0,$E0,$E0,$E0,$E0,$E0,$E0,$E0 ; 117
01:FAA9 E0
01:FAAA E0
01:FAAB E0
01:FAAC E0
01:FAAD E0
01:FAAE E0
01:FAAF E0
01:FAB0 07              	   126:     .byte $07,$07,$07,$07,$07,$07,$07,$07 ; 118
01:FAB1 07
01:FAB2 07
01:FAB3 07
01:FAB4 07
01:FAB5 07
01:FAB6 07
01:FAB7 07
01:FAB8 FF              	   127:     .byte $FF,$FF,$00,$00,$00,$00,$00,$00 ; 119
01:FAB9 FF
01:FABA 00
01:FABB 00
01:FABC 00
01:FABD 00
01:FABE 00
01:FABF 00
01:FAC0 FF              	   128:     .byte $FF,$FF,$FF,$00,$00,$00,$00,$00 ; 120
01:FAC1 FF
01:FAC2 FF
01:FAC3 00
01:FAC4 00
01:FAC5 00
01:FAC6 00
01:FAC7 00
01:FAC8 00              	   129:     .byte $00,$00,$00,$00,$00,$FF,$FF,$FF ; 121
01:FAC9 00
01:FACA 00
01:FACB 00
01:FACC 00
01:FACD FF
01:FACE FF
01:FACF FF
01:FAD0 03              	   130:     .byte $03,$03,$03,$03,$03,$03,$FF,$FF ; 122
01:FAD1 03
01:FAD2 03
01:FAD3 03
01:FAD4 03
01:FAD5 03
01:FAD6 FF
01:FAD7 FF
01:FAD8 00              	   131:     .byte $00,$00,$00,$00,$F0,$F0,$F0,$F0 ; 123
01:FAD9 00
01:FADA 00
01:FADB 00
01:FADC F0
01:FADD F0
01:FADE F0
01:FADF F0
01:FAE0 0F              	   132:     .byte $0F,$0F,$0F,$0F,$00,$00,$00,$00 ; 124
01:FAE1 0F
01:FAE2 0F
01:FAE3 0F
01:FAE4 00
01:FAE5 00
01:FAE6 00
01:FAE7 00
01:FAE8 18              	   133:     .byte $18,$18,$18,$F8,$F8,$00,$00,$00 ; 125
01:FAE9 18
01:FAEA 18
01:FAEB F8
01:FAEC F8
01:FAED 00
01:FAEE 00
01:FAEF 00
01:FAF0 F0              	   134:     .byte $F0,$F0,$F0,$F0,$00,$00,$00,$00 ; 126
01:FAF1 F0
01:FAF2 F0
01:FAF3 F0
01:FAF4 00
01:FAF5 00
01:FAF6 00
01:FAF7 00
01:FAF8 F0              	   135:     .byte $F0,$F0,$F0,$F0,$0F,$0F,$0F,$0F ; 127
01:FAF9 F0
01:FAFA F0
01:FAFB F0
01:FAFC 0F
01:FAFD 0F
01:FAFE 0F
01:FAFF 0F
                        	   136: petscii_4:
01:FB00 3C              	   137:     .byte $3C,$66,$6E,$6E,$60,$62,$3C,$00 ; 128
01:FB01 66
01:FB02 6E
01:FB03 6E
01:FB04 60
01:FB05 62
01:FB06 3C
01:FB07 00
01:FB08 00              	   138:     .byte $00,$00,$3C,$06,$3E,$66,$3E,$00 ; 129
01:FB09 00
01:FB0A 3C
01:FB0B 06
01:FB0C 3E
01:FB0D 66
01:FB0E 3E
01:FB0F 00
01:FB10 00              	   139:     .byte $00,$60,$60,$7C,$66,$66,$7C,$00 ; 130
01:FB11 60
01:FB12 60
01:FB13 7C
01:FB14 66
01:FB15 66
01:FB16 7C
01:FB17 00
01:FB18 00              	   140:     .byte $00,$00,$3C,$60,$60,$60,$3C,$00 ; 131
01:FB19 00
01:FB1A 3C
01:FB1B 60
01:FB1C 60
01:FB1D 60
01:FB1E 3C
01:FB1F 00
01:FB20 00              	   141:     .byte $00,$06,$06,$3E,$66,$66,$3E,$00 ; 132
01:FB21 06
01:FB22 06
01:FB23 3E
01:FB24 66
01:FB25 66
01:FB26 3E
01:FB27 00
01:FB28 00              	   142:     .byte $00,$00,$3C,$66,$7E,$60,$3C,$00 ; 133
01:FB29 00
01:FB2A 3C
01:FB2B 66
01:FB2C 7E
01:FB2D 60
01:FB2E 3C
01:FB2F 00
01:FB30 00              	   143:     .byte $00,$0E,$18,$3E,$18,$18,$18,$00 ; 134
01:FB31 0E
01:FB32 18
01:FB33 3E
01:FB34 18
01:FB35 18
01:FB36 18
01:FB37 00
01:FB38 00              	   144:     .byte $00,$00,$3E,$66,$66,$3E,$06,$7C ; 135
01:FB39 00
01:FB3A 3E
01:FB3B 66
01:FB3C 66
01:FB3D 3E
01:FB3E 06
01:FB3F 7C
01:FB40 00              	   145:     .byte $00,$60,$60,$7C,$66,$66,$66,$00 ; 136
01:FB41 60
01:FB42 60
01:FB43 7C
01:FB44 66
01:FB45 66
01:FB46 66
01:FB47 00
01:FB48 00              	   146:     .byte $00,$18,$00,$38,$18,$18,$3C,$00 ; 137
01:FB49 18
01:FB4A 00
01:FB4B 38
01:FB4C 18
01:FB4D 18
01:FB4E 3C
01:FB4F 00
01:FB50 00              	   147:     .byte $00,$06,$00,$06,$06,$06,$06,$3C ; 138
01:FB51 06
01:FB52 00
01:FB53 06
01:FB54 06
01:FB55 06
01:FB56 06
01:FB57 3C
01:FB58 00              	   148:     .byte $00,$60,$60,$6C,$78,$6C,$66,$00 ; 139
01:FB59 60
01:FB5A 60
01:FB5B 6C
01:FB5C 78
01:FB5D 6C
01:FB5E 66
01:FB5F 00
01:FB60 00              	   149:     .byte $00,$38,$18,$18,$18,$18,$3C,$00 ; 140
01:FB61 38
01:FB62 18
01:FB63 18
01:FB64 18
01:FB65 18
01:FB66 3C
01:FB67 00
01:FB68 00              	   150:     .byte $00,$00,$66,$7F,$7F,$6B,$63,$00 ; 141
01:FB69 00
01:FB6A 66
01:FB6B 7F
01:FB6C 7F
01:FB6D 6B
01:FB6E 63
01:FB6F 00
01:FB70 00              	   151:     .byte $00,$00,$7C,$66,$66,$66,$66,$00 ; 142
01:FB71 00
01:FB72 7C
01:FB73 66
01:FB74 66
01:FB75 66
01:FB76 66
01:FB77 00
01:FB78 00              	   152:     .byte $00,$00,$3C,$66,$66,$66,$3C,$00 ; 143
01:FB79 00
01:FB7A 3C
01:FB7B 66
01:FB7C 66
01:FB7D 66
01:FB7E 3C
01:FB7F 00
01:FB80 00              	   153:     .byte $00,$00,$7C,$66,$66,$7C,$60,$60 ; 144
01:FB81 00
01:FB82 7C
01:FB83 66
01:FB84 66
01:FB85 7C
01:FB86 60
01:FB87 60
01:FB88 00              	   154:     .byte $00,$00,$3E,$66,$66,$3E,$06,$06 ; 145
01:FB89 00
01:FB8A 3E
01:FB8B 66
01:FB8C 66
01:FB8D 3E
01:FB8E 06
01:FB8F 06
01:FB90 00              	   155:     .byte $00,$00,$7C,$66,$60,$60,$60,$00 ; 146
01:FB91 00
01:FB92 7C
01:FB93 66
01:FB94 60
01:FB95 60
01:FB96 60
01:FB97 00
01:FB98 00              	   156:     .byte $00,$00,$3E,$60,$3C,$06,$7C,$00 ; 147
01:FB99 00
01:FB9A 3E
01:FB9B 60
01:FB9C 3C
01:FB9D 06
01:FB9E 7C
01:FB9F 00
01:FBA0 00              	   157:     .byte $00,$18,$7E,$18,$18,$18,$0E,$00 ; 148
01:FBA1 18
01:FBA2 7E
01:FBA3 18
01:FBA4 18
01:FBA5 18
01:FBA6 0E
01:FBA7 00
01:FBA8 00              	   158:     .byte $00,$00,$66,$66,$66,$66,$3E,$00 ; 149
01:FBA9 00
01:FBAA 66
01:FBAB 66
01:FBAC 66
01:FBAD 66
01:FBAE 3E
01:FBAF 00
01:FBB0 00              	   159:     .byte $00,$00,$66,$66,$66,$3C,$18,$00 ; 150
01:FBB1 00
01:FBB2 66
01:FBB3 66
01:FBB4 66
01:FBB5 3C
01:FBB6 18
01:FBB7 00
01:FBB8 00              	   160:     .byte $00,$00,$63,$6B,$7F,$3E,$36,$00 ; 151
01:FBB9 00
01:FBBA 63
01:FBBB 6B
01:FBBC 7F
01:FBBD 3E
01:FBBE 36
01:FBBF 00
01:FBC0 00              	   161:     .byte $00,$00,$66,$3C,$18,$3C,$66,$00 ; 152
01:FBC1 00
01:FBC2 66
01:FBC3 3C
01:FBC4 18
01:FBC5 3C
01:FBC6 66
01:FBC7 00
01:FBC8 00              	   162:     .byte $00,$00,$66,$66,$66,$3E,$0C,$78 ; 153
01:FBC9 00
01:FBCA 66
01:FBCB 66
01:FBCC 66
01:FBCD 3E
01:FBCE 0C
01:FBCF 78
01:FBD0 00              	   163:     .byte $00,$00,$7E,$0C,$18,$30,$7E,$00 ; 154
01:FBD1 00
01:FBD2 7E
01:FBD3 0C
01:FBD4 18
01:FBD5 30
01:FBD6 7E
01:FBD7 00
01:FBD8 3C              	   164:     .byte $3C,$30,$30,$30,$30,$30,$3C,$00 ; 155
01:FBD9 30
01:FBDA 30
01:FBDB 30
01:FBDC 30
01:FBDD 30
01:FBDE 3C
01:FBDF 00
01:FBE0 0C              	   165:     .byte $0C,$12,$30,$7C,$30,$62,$FC,$00 ; 156
01:FBE1 12
01:FBE2 30
01:FBE3 7C
01:FBE4 30
01:FBE5 62
01:FBE6 FC
01:FBE7 00
01:FBE8 3C              	   166:     .byte $3C,$0C,$0C,$0C,$0C,$0C,$3C,$00 ; 157
01:FBE9 0C
01:FBEA 0C
01:FBEB 0C
01:FBEC 0C
01:FBED 0C
01:FBEE 3C
01:FBEF 00
01:FBF0 00              	   167:     .byte $00,$18,$3C,$7E,$18,$18,$18,$18 ; 158
01:FBF1 18
01:FBF2 3C
01:FBF3 7E
01:FBF4 18
01:FBF5 18
01:FBF6 18
01:FBF7 18
01:FBF8 00              	   168:     .byte $00,$10,$30,$7F,$7F,$30,$10,$00 ; 159
01:FBF9 10
01:FBFA 30
01:FBFB 7F
01:FBFC 7F
01:FBFD 30
01:FBFE 10
01:FBFF 00
                        	   169: petscii_5:
01:FC00 00              	   170:     .byte $00,$00,$00,$00,$00,$00,$00,$00 ; 160
01:FC01 00
01:FC02 00
01:FC03 00
01:FC04 00
01:FC05 00
01:FC06 00
01:FC07 00
01:FC08 18              	   171:     .byte $18,$18,$18,$18,$00,$00,$18,$00 ; 161
01:FC09 18
01:FC0A 18
01:FC0B 18
01:FC0C 00
01:FC0D 00
01:FC0E 18
01:FC0F 00
01:FC10 66              	   172:     .byte $66,$66,$66,$00,$00,$00,$00,$00 ; 162
01:FC11 66
01:FC12 66
01:FC13 00
01:FC14 00
01:FC15 00
01:FC16 00
01:FC17 00
01:FC18 66              	   173:     .byte $66,$66,$FF,$66,$FF,$66,$66,$00 ; 163
01:FC19 66
01:FC1A FF
01:FC1B 66
01:FC1C FF
01:FC1D 66
01:FC1E 66
01:FC1F 00
01:FC20 18              	   174:     .byte $18,$3E,$60,$3C,$06,$7C,$18,$00 ; 164
01:FC21 3E
01:FC22 60
01:FC23 3C
01:FC24 06
01:FC25 7C
01:FC26 18
01:FC27 00
01:FC28 62              	   175:     .byte $62,$66,$0C,$18,$30,$66,$46,$00 ; 165
01:FC29 66
01:FC2A 0C
01:FC2B 18
01:FC2C 30
01:FC2D 66
01:FC2E 46
01:FC2F 00
01:FC30 3C              	   176:     .byte $3C,$66,$3C,$38,$67,$66,$3F,$00 ; 166
01:FC31 66
01:FC32 3C
01:FC33 38
01:FC34 67
01:FC35 66
01:FC36 3F
01:FC37 00
01:FC38 06              	   177:     .byte $06,$0C,$18,$00,$00,$00,$00,$00 ; 167
01:FC39 0C
01:FC3A 18
01:FC3B 00
01:FC3C 00
01:FC3D 00
01:FC3E 00
01:FC3F 00
01:FC40 0C              	   178:     .byte $0C,$18,$30,$30,$30,$18,$0C,$00 ; 168
01:FC41 18
01:FC42 30
01:FC43 30
01:FC44 30
01:FC45 18
01:FC46 0C
01:FC47 00
01:FC48 30              	   179:     .byte $30,$18,$0C,$0C,$0C,$18,$30,$00 ; 169
01:FC49 18
01:FC4A 0C
01:FC4B 0C
01:FC4C 0C
01:FC4D 18
01:FC4E 30
01:FC4F 00
01:FC50 00              	   180:     .byte $00,$66,$3C,$FF,$3C,$66,$00,$00 ; 170
01:FC51 66
01:FC52 3C
01:FC53 FF
01:FC54 3C
01:FC55 66
01:FC56 00
01:FC57 00
01:FC58 00              	   181:     .byte $00,$18,$18,$7E,$18,$18,$00,$00 ; 171
01:FC59 18
01:FC5A 18
01:FC5B 7E
01:FC5C 18
01:FC5D 18
01:FC5E 00
01:FC5F 00
01:FC60 00              	   182:     .byte $00,$00,$00,$00,$00,$18,$18,$30 ; 172
01:FC61 00
01:FC62 00
01:FC63 00
01:FC64 00
01:FC65 18
01:FC66 18
01:FC67 30
01:FC68 00              	   183:     .byte $00,$00,$00,$7E,$00,$00,$00,$00 ; 173
01:FC69 00
01:FC6A 00
01:FC6B 7E
01:FC6C 00
01:FC6D 00
01:FC6E 00
01:FC6F 00
01:FC70 00              	   184:     .byte $00,$00,$00,$00,$00,$18,$18,$00 ; 174
01:FC71 00
01:FC72 00
01:FC73 00
01:FC74 00
01:FC75 18
01:FC76 18
01:FC77 00
01:FC78 00              	   185:     .byte $00,$03,$06,$0C,$18,$30,$60,$00 ; 175
01:FC79 03
01:FC7A 06
01:FC7B 0C
01:FC7C 18
01:FC7D 30
01:FC7E 60
01:FC7F 00
01:FC80 3C              	   186:     .byte $3C,$66,$6E,$76,$66,$66,$3C,$00 ; 176
01:FC81 66
01:FC82 6E
01:FC83 76
01:FC84 66
01:FC85 66
01:FC86 3C
01:FC87 00
01:FC88 18              	   187:     .byte $18,$18,$38,$18,$18,$18,$7E,$00 ; 177
01:FC89 18
01:FC8A 38
01:FC8B 18
01:FC8C 18
01:FC8D 18
01:FC8E 7E
01:FC8F 00
01:FC90 3C              	   188:     .byte $3C,$66,$06,$0C,$30,$60,$7E,$00 ; 178
01:FC91 66
01:FC92 06
01:FC93 0C
01:FC94 30
01:FC95 60
01:FC96 7E
01:FC97 00
01:FC98 3C              	   189:     .byte $3C,$66,$06,$1C,$06,$66,$3C,$00 ; 179
01:FC99 66
01:FC9A 06
01:FC9B 1C
01:FC9C 06
01:FC9D 66
01:FC9E 3C
01:FC9F 00
01:FCA0 06              	   190:     .byte $06,$0E,$1E,$66,$7F,$06,$06,$00 ; 180
01:FCA1 0E
01:FCA2 1E
01:FCA3 66
01:FCA4 7F
01:FCA5 06
01:FCA6 06
01:FCA7 00
01:FCA8 7E              	   191:     .byte $7E,$60,$7C,$06,$06,$66,$3C,$00 ; 181
01:FCA9 60
01:FCAA 7C
01:FCAB 06
01:FCAC 06
01:FCAD 66
01:FCAE 3C
01:FCAF 00
01:FCB0 3C              	   192:     .byte $3C,$66,$60,$7C,$66,$66,$3C,$00 ; 182
01:FCB1 66
01:FCB2 60
01:FCB3 7C
01:FCB4 66
01:FCB5 66
01:FCB6 3C
01:FCB7 00
01:FCB8 7E              	   193:     .byte $7E,$66,$0C,$18,$18,$18,$18,$00 ; 183
01:FCB9 66
01:FCBA 0C
01:FCBB 18
01:FCBC 18
01:FCBD 18
01:FCBE 18
01:FCBF 00
01:FCC0 3C              	   194:     .byte $3C,$66,$66,$3C,$66,$66,$3C,$00 ; 184
01:FCC1 66
01:FCC2 66
01:FCC3 3C
01:FCC4 66
01:FCC5 66
01:FCC6 3C
01:FCC7 00
01:FCC8 3C              	   195:     .byte $3C,$66,$66,$3E,$06,$66,$3C,$00 ; 185
01:FCC9 66
01:FCCA 66
01:FCCB 3E
01:FCCC 06
01:FCCD 66
01:FCCE 3C
01:FCCF 00
01:FCD0 00              	   196:     .byte $00,$00,$18,$00,$00,$18,$00,$00 ; 186
01:FCD1 00
01:FCD2 18
01:FCD3 00
01:FCD4 00
01:FCD5 18
01:FCD6 00
01:FCD7 00
01:FCD8 00              	   197:     .byte $00,$00,$18,$00,$00,$18,$18,$30 ; 187
01:FCD9 00
01:FCDA 18
01:FCDB 00
01:FCDC 00
01:FCDD 18
01:FCDE 18
01:FCDF 30
01:FCE0 0E              	   198:     .byte $0E,$18,$30,$60,$30,$18,$0E,$00 ; 188
01:FCE1 18
01:FCE2 30
01:FCE3 60
01:FCE4 30
01:FCE5 18
01:FCE6 0E
01:FCE7 00
01:FCE8 00              	   199:     .byte $00,$00,$7E,$00,$7E,$00,$00,$00 ; 189
01:FCE9 00
01:FCEA 7E
01:FCEB 00
01:FCEC 7E
01:FCED 00
01:FCEE 00
01:FCEF 00
01:FCF0 70              	   200:     .byte $70,$18,$0C,$06,$0C,$18,$70,$00 ; 190
01:FCF1 18
01:FCF2 0C
01:FCF3 06
01:FCF4 0C
01:FCF5 18
01:FCF6 70
01:FCF7 00
01:FCF8 3C              	   201:     .byte $3C,$66,$06,$0C,$18,$00,$18,$00 ; 191
01:FCF9 66
01:FCFA 06
01:FCFB 0C
01:FCFC 18
01:FCFD 00
01:FCFE 18
01:FCFF 00
                        	   202: petscii_6:
01:FD00 00              	   203:     .byte $00,$00,$00,$FF,$FF,$00,$00,$00 ; 192
01:FD01 00
01:FD02 00
01:FD03 FF
01:FD04 FF
01:FD05 00
01:FD06 00
01:FD07 00
01:FD08 18              	   204:     .byte $18,$3C,$66,$7E,$66,$66,$66,$00 ; 193
01:FD09 3C
01:FD0A 66
01:FD0B 7E
01:FD0C 66
01:FD0D 66
01:FD0E 66
01:FD0F 00
01:FD10 7C              	   205:     .byte $7C,$66,$66,$7C,$66,$66,$7C,$00 ; 194
01:FD11 66
01:FD12 66
01:FD13 7C
01:FD14 66
01:FD15 66
01:FD16 7C
01:FD17 00
01:FD18 3C              	   206:     .byte $3C,$66,$60,$60,$60,$66,$3C,$00 ; 195
01:FD19 66
01:FD1A 60
01:FD1B 60
01:FD1C 60
01:FD1D 66
01:FD1E 3C
01:FD1F 00
01:FD20 78              	   207:     .byte $78,$6C,$66,$66,$66,$6C,$78,$00 ; 196
01:FD21 6C
01:FD22 66
01:FD23 66
01:FD24 66
01:FD25 6C
01:FD26 78
01:FD27 00
01:FD28 7E              	   208:     .byte $7E,$60,$60,$78,$60,$60,$7E,$00 ; 197
01:FD29 60
01:FD2A 60
01:FD2B 78
01:FD2C 60
01:FD2D 60
01:FD2E 7E
01:FD2F 00
01:FD30 7E              	   209:     .byte $7E,$60,$60,$78,$60,$60,$60,$00 ; 198
01:FD31 60
01:FD32 60
01:FD33 78
01:FD34 60
01:FD35 60
01:FD36 60
01:FD37 00
01:FD38 3C              	   210:     .byte $3C,$66,$60,$6E,$66,$66,$3C,$00 ; 199
01:FD39 66
01:FD3A 60
01:FD3B 6E
01:FD3C 66
01:FD3D 66
01:FD3E 3C
01:FD3F 00
01:FD40 66              	   211:     .byte $66,$66,$66,$7E,$66,$66,$66,$00 ; 200
01:FD41 66
01:FD42 66
01:FD43 7E
01:FD44 66
01:FD45 66
01:FD46 66
01:FD47 00
01:FD48 3C              	   212:     .byte $3C,$18,$18,$18,$18,$18,$3C,$00 ; 201
01:FD49 18
01:FD4A 18
01:FD4B 18
01:FD4C 18
01:FD4D 18
01:FD4E 3C
01:FD4F 00
01:FD50 1E              	   213:     .byte $1E,$0C,$0C,$0C,$0C,$6C,$38,$00 ; 202
01:FD51 0C
01:FD52 0C
01:FD53 0C
01:FD54 0C
01:FD55 6C
01:FD56 38
01:FD57 00
01:FD58 66              	   214:     .byte $66,$6C,$78,$70,$78,$6C,$66,$00 ; 203
01:FD59 6C
01:FD5A 78
01:FD5B 70
01:FD5C 78
01:FD5D 6C
01:FD5E 66
01:FD5F 00
01:FD60 60              	   215:     .byte $60,$60,$60,$60,$60,$60,$7E,$00 ; 204
01:FD61 60
01:FD62 60
01:FD63 60
01:FD64 60
01:FD65 60
01:FD66 7E
01:FD67 00
01:FD68 63              	   216:     .byte $63,$77,$7F,$6B,$63,$63,$63,$00 ; 205
01:FD69 77
01:FD6A 7F
01:FD6B 6B
01:FD6C 63
01:FD6D 63
01:FD6E 63
01:FD6F 00
01:FD70 66              	   217:     .byte $66,$76,$7E,$7E,$6E,$66,$66,$00 ; 206
01:FD71 76
01:FD72 7E
01:FD73 7E
01:FD74 6E
01:FD75 66
01:FD76 66
01:FD77 00
01:FD78 3C              	   218:     .byte $3C,$66,$66,$66,$66,$66,$3C,$00 ; 207
01:FD79 66
01:FD7A 66
01:FD7B 66
01:FD7C 66
01:FD7D 66
01:FD7E 3C
01:FD7F 00
01:FD80 7C              	   219:     .byte $7C,$66,$66,$7C,$60,$60,$60,$00 ; 208
01:FD81 66
01:FD82 66
01:FD83 7C
01:FD84 60
01:FD85 60
01:FD86 60
01:FD87 00
01:FD88 3C              	   220:     .byte $3C,$66,$66,$66,$66,$3C,$0E,$00 ; 209
01:FD89 66
01:FD8A 66
01:FD8B 66
01:FD8C 66
01:FD8D 3C
01:FD8E 0E
01:FD8F 00
01:FD90 7C              	   221:     .byte $7C,$66,$66,$7C,$78,$6C,$66,$00 ; 210
01:FD91 66
01:FD92 66
01:FD93 7C
01:FD94 78
01:FD95 6C
01:FD96 66
01:FD97 00
01:FD98 3C              	   222:     .byte $3C,$66,$60,$3C,$06,$66,$3C,$00 ; 211
01:FD99 66
01:FD9A 60
01:FD9B 3C
01:FD9C 06
01:FD9D 66
01:FD9E 3C
01:FD9F 00
01:FDA0 7E              	   223:     .byte $7E,$18,$18,$18,$18,$18,$18,$00 ; 212
01:FDA1 18
01:FDA2 18
01:FDA3 18
01:FDA4 18
01:FDA5 18
01:FDA6 18
01:FDA7 00
01:FDA8 66              	   224:     .byte $66,$66,$66,$66,$66,$66,$3C,$00 ; 213
01:FDA9 66
01:FDAA 66
01:FDAB 66
01:FDAC 66
01:FDAD 66
01:FDAE 3C
01:FDAF 00
01:FDB0 66              	   225:     .byte $66,$66,$66,$66,$66,$3C,$18,$00 ; 214
01:FDB1 66
01:FDB2 66
01:FDB3 66
01:FDB4 66
01:FDB5 3C
01:FDB6 18
01:FDB7 00
01:FDB8 63              	   226:     .byte $63,$63,$63,$6B,$7F,$77,$63,$00 ; 215
01:FDB9 63
01:FDBA 63
01:FDBB 6B
01:FDBC 7F
01:FDBD 77
01:FDBE 63
01:FDBF 00
01:FDC0 66              	   227:     .byte $66,$66,$3C,$18,$3C,$66,$66,$00 ; 216
01:FDC1 66
01:FDC2 3C
01:FDC3 18
01:FDC4 3C
01:FDC5 66
01:FDC6 66
01:FDC7 00
01:FDC8 66              	   228:     .byte $66,$66,$66,$3C,$18,$18,$18,$00 ; 217
01:FDC9 66
01:FDCA 66
01:FDCB 3C
01:FDCC 18
01:FDCD 18
01:FDCE 18
01:FDCF 00
01:FDD0 7E              	   229:     .byte $7E,$06,$0C,$18,$30,$60,$7E,$00 ; 218
01:FDD1 06
01:FDD2 0C
01:FDD3 18
01:FDD4 30
01:FDD5 60
01:FDD6 7E
01:FDD7 00
01:FDD8 18              	   230:     .byte $18,$18,$18,$FF,$FF,$18,$18,$18 ; 219
01:FDD9 18
01:FDDA 18
01:FDDB FF
01:FDDC FF
01:FDDD 18
01:FDDE 18
01:FDDF 18
01:FDE0 C0              	   231:     .byte $C0,$C0,$30,$30,$C0,$C0,$30,$30 ; 220
01:FDE1 C0
01:FDE2 30
01:FDE3 30
01:FDE4 C0
01:FDE5 C0
01:FDE6 30
01:FDE7 30
01:FDE8 18              	   232:     .byte $18,$18,$18,$18,$18,$18,$18,$18 ; 221
01:FDE9 18
01:FDEA 18
01:FDEB 18
01:FDEC 18
01:FDED 18
01:FDEE 18
01:FDEF 18
01:FDF0 33              	   233:     .byte $33,$33,$CC,$CC,$33,$33,$CC,$CC ; 222
01:FDF1 33
01:FDF2 CC
01:FDF3 CC
01:FDF4 33
01:FDF5 33
01:FDF6 CC
01:FDF7 CC
01:FDF8 33              	   234:     .byte $33,$99,$CC,$66,$33,$99,$CC,$66 ; 223
01:FDF9 99
01:FDFA CC
01:FDFB 66
01:FDFC 33
01:FDFD 99
01:FDFE CC
01:FDFF 66
                        	   235: petscii_7:
01:FE00 00              	   236:     .byte $00,$00,$00,$00,$00,$00,$00,$00 ; 224
01:FE01 00
01:FE02 00
01:FE03 00
01:FE04 00
01:FE05 00
01:FE06 00
01:FE07 00
01:FE08 F0              	   237:     .byte $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; 225
01:FE09 F0
01:FE0A F0
01:FE0B F0
01:FE0C F0
01:FE0D F0
01:FE0E F0
01:FE0F F0
01:FE10 00              	   238:     .byte $00,$00,$00,$00,$FF,$FF,$FF,$FF ; 226
01:FE11 00
01:FE12 00
01:FE13 00
01:FE14 FF
01:FE15 FF
01:FE16 FF
01:FE17 FF
01:FE18 FF              	   239:     .byte $FF,$00,$00,$00,$00,$00,$00,$00 ; 227
01:FE19 00
01:FE1A 00
01:FE1B 00
01:FE1C 00
01:FE1D 00
01:FE1E 00
01:FE1F 00
01:FE20 00              	   240:     .byte $00,$00,$00,$00,$00,$00,$00,$FF ; 228
01:FE21 00
01:FE22 00
01:FE23 00
01:FE24 00
01:FE25 00
01:FE26 00
01:FE27 FF
01:FE28 80              	   241:     .byte $80,$80,$80,$80,$80,$80,$80,$80 ; 229
01:FE29 80
01:FE2A 80
01:FE2B 80
01:FE2C 80
01:FE2D 80
01:FE2E 80
01:FE2F 80
01:FE30 CC              	   242:     .byte $CC,$CC,$33,$33,$CC,$CC,$33,$33 ; 230
01:FE31 CC
01:FE32 33
01:FE33 33
01:FE34 CC
01:FE35 CC
01:FE36 33
01:FE37 33
01:FE38 01              	   243:     .byte $01,$01,$01,$01,$01,$01,$01,$01 ; 231
01:FE39 01
01:FE3A 01
01:FE3B 01
01:FE3C 01
01:FE3D 01
01:FE3E 01
01:FE3F 01
01:FE40 00              	   244:     .byte $00,$00,$00,$00,$CC,$CC,$33,$33 ; 232
01:FE41 00
01:FE42 00
01:FE43 00
01:FE44 CC
01:FE45 CC
01:FE46 33
01:FE47 33
01:FE48 CC              	   245:     .byte $CC,$99,$33,$66,$CC,$99,$33,$66 ; 233
01:FE49 99
01:FE4A 33
01:FE4B 66
01:FE4C CC
01:FE4D 99
01:FE4E 33
01:FE4F 66
01:FE50 03              	   246:     .byte $03,$03,$03,$03,$03,$03,$03,$03 ; 234
01:FE51 03
01:FE52 03
01:FE53 03
01:FE54 03
01:FE55 03
01:FE56 03
01:FE57 03
01:FE58 18              	   247:     .byte $18,$18,$18,$1F,$1F,$18,$18,$18 ; 235
01:FE59 18
01:FE5A 18
01:FE5B 1F
01:FE5C 1F
01:FE5D 18
01:FE5E 18
01:FE5F 18
01:FE60 00              	   248:     .byte $00,$00,$00,$00,$0F,$0F,$0F,$0F ; 236
01:FE61 00
01:FE62 00
01:FE63 00
01:FE64 0F
01:FE65 0F
01:FE66 0F
01:FE67 0F
01:FE68 18              	   249:     .byte $18,$18,$18,$1F,$1F,$00,$00,$00 ; 237
01:FE69 18
01:FE6A 18
01:FE6B 1F
01:FE6C 1F
01:FE6D 00
01:FE6E 00
01:FE6F 00
01:FE70 00              	   250:     .byte $00,$00,$00,$F8,$F8,$18,$18,$18 ; 238
01:FE71 00
01:FE72 00
01:FE73 F8
01:FE74 F8
01:FE75 18
01:FE76 18
01:FE77 18
01:FE78 00              	   251:     .byte $00,$00,$00,$00,$00,$00,$FF,$FF ; 239
01:FE79 00
01:FE7A 00
01:FE7B 00
01:FE7C 00
01:FE7D 00
01:FE7E FF
01:FE7F FF
01:FE80 00              	   252:     .byte $00,$00,$00,$1F,$1F,$18,$18,$18 ; 240
01:FE81 00
01:FE82 00
01:FE83 1F
01:FE84 1F
01:FE85 18
01:FE86 18
01:FE87 18
01:FE88 18              	   253:     .byte $18,$18,$18,$FF,$FF,$00,$00,$00 ; 241
01:FE89 18
01:FE8A 18
01:FE8B FF
01:FE8C FF
01:FE8D 00
01:FE8E 00
01:FE8F 00
01:FE90 00              	   254:     .byte $00,$00,$00,$FF,$FF,$18,$18,$18 ; 242
01:FE91 00
01:FE92 00
01:FE93 FF
01:FE94 FF
01:FE95 18
01:FE96 18
01:FE97 18
01:FE98 18              	   255:     .byte $18,$18,$18,$F8,$F8,$18,$18,$18 ; 243
01:FE99 18
01:FE9A 18
01:FE9B F8
01:FE9C F8
01:FE9D 18
01:FE9E 18
01:FE9F 18
01:FEA0 C0              	   256:     .byte $C0,$C0,$C0,$C0,$C0,$C0,$C0,$C0 ; 244
01:FEA1 C0
01:FEA2 C0
01:FEA3 C0
01:FEA4 C0
01:FEA5 C0
01:FEA6 C0
01:FEA7 C0
01:FEA8 E0              	   257:     .byte $E0,$E0,$E0,$E0,$E0,$E0,$E0,$E0 ; 245
01:FEA9 E0
01:FEAA E0
01:FEAB E0
01:FEAC E0
01:FEAD E0
01:FEAE E0
01:FEAF E0
01:FEB0 07              	   258:     .byte $07,$07,$07,$07,$07,$07,$07,$07 ; 246
01:FEB1 07
01:FEB2 07
01:FEB3 07
01:FEB4 07
01:FEB5 07
01:FEB6 07
01:FEB7 07
01:FEB8 FF              	   259:     .byte $FF,$FF,$00,$00,$00,$00,$00,$00 ; 247
01:FEB9 FF
01:FEBA 00
01:FEBB 00
01:FEBC 00
01:FEBD 00
01:FEBE 00
01:FEBF 00
01:FEC0 FF              	   260:     .byte $FF,$FF,$FF,$00,$00,$00,$00,$00 ; 248
01:FEC1 FF
01:FEC2 FF
01:FEC3 00
01:FEC4 00
01:FEC5 00
01:FEC6 00
01:FEC7 00
01:FEC8 00              	   261:     .byte $00,$00,$00,$00,$00,$FF,$FF,$FF ; 249
01:FEC9 00
01:FECA 00
01:FECB 00
01:FECC 00
01:FECD FF
01:FECE FF
01:FECF FF
01:FED0 01              	   262:     .byte $01,$03,$06,$6C,$78,$70,$60,$00 ; 250
01:FED1 03
01:FED2 06
01:FED3 6C
01:FED4 78
01:FED5 70
01:FED6 60
01:FED7 00
01:FED8 00              	   263:     .byte $00,$00,$00,$00,$F0,$F0,$F0,$F0 ; 251
01:FED9 00
01:FEDA 00
01:FEDB 00
01:FEDC F0
01:FEDD F0
01:FEDE F0
01:FEDF F0
01:FEE0 0F              	   264:     .byte $0F,$0F,$0F,$0F,$00,$00,$00,$00 ; 252
01:FEE1 0F
01:FEE2 0F
01:FEE3 0F
01:FEE4 00
01:FEE5 00
01:FEE6 00
01:FEE7 00
01:FEE8 18              	   265:     .byte $18,$18,$18,$F8,$F8,$00,$00,$00 ; 253
01:FEE9 18
01:FEEA 18
01:FEEB F8
01:FEEC F8
01:FEED 00
01:FEEE 00
01:FEEF 00
01:FEF0 F0              	   266:     .byte $F0,$F0,$F0,$F0,$00,$00,$00,$00 ; 254
01:FEF1 F0
01:FEF2 F0
01:FEF3 F0
01:FEF4 00
01:FEF5 00
01:FEF6 00
01:FEF7 00
01:FEF8 F0              	   267:     .byte $F0,$F0,$F0,$F0,$0F,$0F,$0F,$0F ; 255
01:FEF9 F0
01:FEFA F0
01:FEFB F0
01:FEFC 0F
01:FEFD 0F
01:FEFE 0F
01:FEFF 0F
                        	   268: 

Source: "x16_hardware_tester.s"
                        	   152: 
                        	   153:     ; ======== NMI / IRQ =======
                        	   154: nmi:
                        	   155:     ; TODO: implement this
                        	   156:     ; FIXME: ugly hack!
01:FF00 4C00C0          	   157:     jmp reset
01:FF03 40              	   158:     rti
                        	   159:    
                        	   160: irq:
                        	   161:     ; Right now we also jump to a certain RAM adress where we copy our irq handling code (which may vary)
01:FF04 4C0010          	   162:     jmp IRQ_RAM_ADDRES
                        	   163: 
                        	   164: 
                        	   165:     .org $fffa
02:FFFA 00FF            	   166:     .word nmi
02:FFFC 00C0            	   167:     .word reset
02:FFFE 04FF            	   168:     .word irq
                        	   169: 
                        	   170:     ; 31 ROM banks filled entirely with their own bank index
                        	   171:     
02:0000 01              	   172:     .fill 16384, $01
02:0001 *
02:4000 02              	   173:     .fill 16384, $02
02:4001 *
02:8000 03              	   174:     .fill 16384, $03
02:8001 *
02:C000 04              	   175:     .fill 16384, $04
02:C001 *
02:0000 05              	   176:     .fill 16384, $05
02:0001 *
02:4000 06              	   177:     .fill 16384, $06
02:4001 *
02:8000 07              	   178:     .fill 16384, $07
02:8001 *
02:C000 08              	   179:     .fill 16384, $08
02:C001 *
02:0000 09              	   180:     .fill 16384, $09
02:0001 *
02:4000 0A              	   181:     .fill 16384, $0A
02:4001 *
02:8000 0B              	   182:     .fill 16384, $0B
02:8001 *
02:C000 0C              	   183:     .fill 16384, $0C
02:C001 *
02:0000 0D              	   184:     .fill 16384, $0D
02:0001 *
02:4000 0E              	   185:     .fill 16384, $0E
02:4001 *
02:8000 0F              	   186:     .fill 16384, $0F
02:8001 *
                        	   187: 
02:C000 10              	   188:     .fill 16384, $10
02:C001 *
02:0000 11              	   189:     .fill 16384, $11
02:0001 *
02:4000 12              	   190:     .fill 16384, $12
02:4001 *
02:8000 13              	   191:     .fill 16384, $13
02:8001 *
02:C000 14              	   192:     .fill 16384, $14
02:C001 *
02:0000 15              	   193:     .fill 16384, $15
02:0001 *
02:4000 16              	   194:     .fill 16384, $16
02:4001 *
02:8000 17              	   195:     .fill 16384, $17
02:8001 *
02:C000 18              	   196:     .fill 16384, $18
02:C001 *
02:0000 19              	   197:     .fill 16384, $19
02:0001 *
02:4000 1A              	   198:     .fill 16384, $1A
02:4001 *
02:8000 1B              	   199:     .fill 16384, $1B
02:8001 *
02:C000 1C              	   200:     .fill 16384, $1C
02:C001 *
02:0000 1D              	   201:     .fill 16384, $1D
02:0001 *
02:4000 1E              	   202:     .fill 16384, $1E
02:4001 *
02:8000 1F              	   203:     .fill 16384, $1F
02:8001 *
                        	   204: 


Symbols by name:
BAD_VALUE                        E:001A
BANKED_RAM_END_ADDR              E:C000
BANKED_RAM_START_ADDR            E:A000
BANKED_ROM_END_ADDR              E:0000
BANKED_ROM_START_ADDR            E:C000
BANK_TESTING                     E:0012
BYTE_TO_PRINT                    E:000C
COLOR_ERROR                      E:0042
COLOR_HEADER                     E:0047
COLOR_NORMAL                     E:0041
COLOR_OK                         E:0045
COLOR_TITLE                      E:0043
COLOR_WARNING                    E:0048
COUNTER_IS_RUNNING               E:0022
CURSOR_X                         E:0009
CURSOR_Y                         E:000A
DECIMAL_STRING                   E:000D
END_ADDR_HIGH                    E:0011
ESTIMATED_CPU_SPEED_PCM          E:0023
ESTIMATED_CPU_SPEED_VSYNC        E:0024
FIXED_RAM_END_ADDR               E:9F00
FIXED_RAM_START_ADDR             E:0200
INDENTATION                      E:000B
INDENT_SIZE                      E:0002
IO3_BASE_ADDRESS                 E:9F60
IRQ_RAM_ADDRES                   E:1000
MARGIN                           E:0002
MEMORY_ADDR_TESTING              E:0014
NR_OF_ROM_BANKS                  E:0020
NR_OF_UNIQUE_RAM_BANKS           E:0018
NR_OF_WORKING_RAM_BANKS          E:0016
RAM_BANK                         E:0000
ROM_BANK                         E:0001
ROM_TEST_CODE                    E:4000
SPI_CHIP_DESELECT_AND_SLOW       E:0002
SPI_CHIP_SELECT_AND_SLOW         E:0003
START_ADDR_HIGH                  E:0010
TEXT_COLOR                       E:0008
TEXT_TO_PRINT                    E:0006
TILE_MAP_HEIGHT                  E:0040
TILE_MAP_WIDTH                   E:0080
TIMING_COUNTER                   E:0020
TMP1                             E:0002
TMP2                             E:0003
TMP4                             E:0005
VERA_ADDR_BANK                   E:9F22
VERA_ADDR_HIGH                   E:9F21
VERA_ADDR_LOW                    E:9F20
VERA_AUDIO_CTRL                  E:9F3B
VERA_AUDIO_DATA                  E:9F3D
VERA_AUDIO_RATE                  E:9F3C
VERA_CTRL                        E:9F25
VERA_DATA0                       E:9F23
VERA_DATA1                       E:9F24
VERA_DC_HSCALE                   E:9F2A
VERA_DC_VIDEO                    E:9F29
VERA_DC_VSCALE                   E:9F2B
VERA_IEN                         E:9F26
VERA_ISR                         E:9F27
VERA_L0_CONFIG                   E:9F2D
VERA_L0_HSCROLL_H                E:9F31
VERA_L0_HSCROLL_L                E:9F30
VERA_L0_MAPBASE                  E:9F2E
VERA_L0_TILEBASE                 E:9F2F
VERA_L0_VSCROLL_H                E:9F33
VERA_L0_VSCROLL_L                E:9F32
VERA_L1_HSCROLL_L                E:9F37
VERA_SPI_CTRL                    E:9F3F
VERA_SPI_DATA                    E:9F3E
audio_buffer_is_not_full         A:CDA2
bank_already_counted             A:C8FA
bank_is_not_working              A:C8D5
banked_ram_header                A:C75E
banked_ram_is_not_ok             A:C88C
banked_ram_is_ok                 A:C870
banked_rom_header                A:C970
banked_rom_is_not_ok             A:CA1D
banked_rom_is_ok                 A:CA0B
between_A_and_a                  A:C1CC
char_between_A_and_a             A:C403
char_conversion_done             A:C40F
char_convert_done                A:C1D8
char_larger_than_or_equal_to_a   A:C409
char_smaller_than_a              A:C3FC
check_for_working_next_ram_bank  A:C8B0
check_next_ram_bank              A:C8DD
check_next_ram_block             A:C6B8
check_next_rom_block             A:CA40
check_ram_block_00               A:C6CB
check_ram_block_0_00             A:C232
check_ram_block_0_FF             A:C223
check_ram_block_1_00             A:C254
check_ram_block_1_FF             A:C243
check_ram_block_FF               A:C6BC
check_rom_block                  A:CA44
color_cpu_speed_done             A:CE77
command0_not_in_idle_state       A:D010
command0_success                 A:CFFA
command0_timed_out               A:CFE8
command41_still_in_idle_state    A:CFA0
command41_success                A:CF8A
command41_timed_out              A:CF78
command55_not_in_idle_state      A:CFA8
command55_success                A:CF6F
command55_timed_out              A:CF5D
command8_not_in_idle_state       A:D06C
command8_success                 A:D04A
command8_timed_out               A:D038
copy_back_tiles_and_map_to_high  A:CC72
copy_irq_cpu_speed_measurment_c  A:CDC6
copy_petscii_0                   A:C09D
copy_petscii_1                   A:C0A8
copy_petscii_2                   A:C0B3
copy_petscii_3                   A:C0BE
copy_petscii_4                   A:C0C9
copy_petscii_5                   A:C0D4
copy_petscii_6                   A:C0DF
copy_petscii_7                   A:C0EA
copy_rom_test_code_byte          A:C9CC
copy_tiles_and_map_to_low_vram   A:CC5C
cpu_speed_done_pcm               A:CD77
cpu_speed_done_vsync             A:CE3E
cpu_speed_too_high_pcm           A:CD90
cpu_speed_too_low_vsync          A:CE46
cpu_speeds_differ                A:CE75
determine_nr_of_ram_banks        A:C8A4
done_measuring_cpu_speed_pcm     A:CDB1
done_measuring_cpu_speed_vsync   A:CE67
done_nr_of_banks                 A:C8FC
done_print_fixed_ram_message     A:C1AB
done_print_testing_message       A:C1E4
done_print_text                  A:C41B
done_print_title_message         A:C172
done_printing_nr_of_banked_ram   A:C83B
done_printing_unique_banks       A:C96C
done_printing_working_banks      A:C92A
done_testing_banked_ram          A:C8A0
done_testing_banked_rom          A:CA31
done_testing_fixed_ram           A:C75A
done_testing_ram                 A:C6E5
done_vram_test                   A:CC58
done_with_command0_do_not_proce  A:D015
done_with_command0_proceed       A:D01F
done_with_command8_do_not_proce  A:D071
done_with_command8_proceed       A:D07B
done_with_initialize_do_not_pro  A:CFAD
done_with_initialize_proceed     A:CFB7
done_with_sd_checks              A:C3AA
end_of_interrupt                 A:CE99
end_of_irq_cpu_speed_measurment  A:CEA0
end_of_test_rom_bank             A:CA63
fill_pcm_audio_block_with_ff     A:CD20
fill_pcm_audio_byte              A:CD4C
fill_pcm_audio_byte_with_ff      A:CD22
fixed_ram_between_A_and_a        A:C193
fixed_ram_char_convert_done      A:C19F
fixed_ram_header_message         A:C6E6
fixed_ram_is_not_ok              A:C746
fixed_ram_is_ok                  A:C734
fixed_ram_larger_than_or_equal_  A:C199
fixed_ram_smaller_than_a         A:C18C
high_nibble_is_larger_than_or_e  A:C689
high_nibble_ready                A:C68C
increment_counter                A:CDF6
irq                              A:FF04
irq_cpu_speed_measurment         A:CE8A
larger_than_or_equal_to_a        A:C1D2
loop                             A:C3B6
low_nibble_is_larger_than_or_eq  A:C6A4
low_nibble_ready                 A:C6A7
lower_vram_not_ok                A:CC3A
lower_vram_not_ok_jmp            A:CB54
measure_cpu_speed_using_pcm      A:CD03
measure_cpu_speed_using_vsync    A:CDB5
measured_ok_cpu_speed_pcm        A:CD79
measured_ok_cpu_speed_vsync      A:CE40
mhz_message                      A:CB0E
mod10                            A:C475
move_cursor_to_next_line         A:C3CF
next_ram_bank_to_test            A:C84A
next_rom_bank_to_test            A:C9F2
next_vram_block_00               A:CB89
next_vram_block_FF               A:CB6B
next_vram_block_copy             A:CC61
next_vram_block_copy_back        A:CC77
next_vram_block_high_00          A:CBD4
next_vram_block_high_FF          A:CBB4
next_vram_byte_00                A:CB8B
next_vram_byte_FF                A:CB6D
next_vram_byte_copy              A:CC63
next_vram_byte_copy_back         A:CC79
next_vram_byte_high_00           A:CBD6
next_vram_byte_high_FF           A:CBB6
nmi                              A:FF00
no_buffer_fill_message           A:CB23
no_increment                     A:CDFC
no_increment_counter_pcm         A:CD55
not_ok_message                   A:C3BC
nr_of_ram_banks_256_message      A:C7EF
nr_of_unique_ram_banks_message   A:C7C5
nr_of_working_ram_banks_message  A:C79A
ok_message                       A:C3B9
petscii_0                        A:F700
petscii_1                        A:F800
petscii_2                        A:F900
petscii_3                        A:FA00
petscii_4                        A:FB00
petscii_5                        A:FC00
petscii_6                        A:FD00
petscii_7                        A:FE00
print_256_unique                 A:C95D
print_256_unique_while_testing   A:C830
print_256_working                A:C91B
print_banked_address             A:C4F8
print_banked_ram_header          A:C7F3
print_banked_rom_header          A:C9A8
print_byte_as_decimal            A:C425
print_byte_as_hex                A:C679
print_cpu_speed_vsync            A:CE6C
print_fixed_ram_address          A:C49B
print_fixed_ram_header           A:C172
print_fixed_ram_message          A:C183
print_hundreds                   A:C450
print_lower_vram_address         A:C566
print_next_char                  A:C3F4
print_ones                       A:C468
print_spi_cmd_error              A:C638
print_tens                       A:C45C
print_testing_message            A:C1BC
print_testing_zp_stack_ram       A:C1AB
print_text_zero                  A:C3EC
print_title                      A:C116
print_title_message              A:C127
print_unique_banks               A:C955
print_unique_banks_not_ok        A:C94A
print_unique_banks_ok            A:C951
print_upper_vram_address         A:C5CF
print_vera_sd_header             A:CF27
print_vera_video_header          A:CB32
ram_block_0                      E:0000
ram_block_1                      E:0100
ram_is_not_ok                    A:C6E1
reset                            A:C000
rom_is_not_ok                    A:CA59
setup_cursor                     A:C3D8
setup_vram_address_00000         A:CC88
setup_vram_address_10000         A:CCB1
setup_vram_address_copy          A:CCDA
smaller_than_a                   A:C1C5
spi_command0_timeout             A:D0AA
spi_command41_timeout            A:D130
spi_command55_timeout            A:D104
spi_command8_timeout             A:D0DA
spi_command_error                A:C3C3
spi_dummy_clock_loop             A:CFD2
spi_read_byte                    A:D132
spi_send_command0                A:D080
spi_send_command41               A:D106
spi_send_command55               A:D0DC
spi_send_command8                A:D0AC
spi_wait_command0                A:D09A
spi_wait_command41               A:D120
spi_wait_command55               A:D0F4
spi_wait_command8                A:D0CA
spi_write_byte                   A:D140
start_counter                    A:CE95
start_unique_ram_check           A:C8DB
test_banked_ram                  A:C815
test_fixed_ram                   A:C718
test_ram_block                   A:C6B2
test_rom_bank                    A:CA35
test_rom_banks                   A:C9CA
test_vram                        A:CB57
test_zp_stack_ram_start          A:C21F
testing_banked_ram_message1      A:C76A
testing_banked_ram_message2      A:C773
testing_banked_rom_message       A:C97C
testing_fixed_ram_message        A:C6F1
testing_measure_cpu_speed_using  A:CADE
testing_measure_cpu_speed_using  A:CAB3
testing_message                  A:C1E7
testing_vram_message             A:CA71
testing_vsync_irq_message        A:CA95
title_between_A_and_a            A:C137
title_char_convert_done          A:C143
title_larger_than_or_equal_to_a  A:C13D
title_message                    A:C14F
title_smaller_than_a             A:C130
too_high_message                 A:CB12
too_low_message                  A:CB1B
upper_vram_not_ok                A:CC0E
vera_boot_snooze                 A:C014
vera_check_sdc_version           A:D024
vera_check_sdc_version_message   A:CED0
vera_clear_fill_tile_map         A:C104
vera_clear_fill_tile_map_row     A:C106
vera_clear_start                 A:C0F3
vera_initialize_sd_card          A:CF49
vera_ready                       A:C01C
vera_reset_sd_card               A:CFBC
vera_sd_header                   A:CEA0
vera_sd_initialize_message       A:CEF4
vera_sd_no_card_detected         A:CF0E
vera_sd_reset_message            A:CEAB
vera_sd_timeout_message          A:CF1F
vera_tilemap_done                A:C04B
vera_video_header                A:CA63
wait_block_during_pcm_playback   A:CD37
wait_for_vera                    A:C003
wait_single_during_pcm_playback  A:CD39
wait_spi_read_busy               A:D137
wait_spi_write_busy              A:D143
waiting_no_increment_vsync       A:CDEC
waiting_to_start_counter_vsync   A:CDE4
waiting_too_long_vsync           A:CE58
zp_stack_done_checking_ram       A:C263
zp_stack_high_data_nibble_is_la  A:C333
zp_stack_high_data_nibble_ready  A:C336
zp_stack_high_nibble_is_larger_  A:C2EB
zp_stack_high_nibble_ready       A:C2EE
zp_stack_loop_ram_not_ok         A:C362
zp_stack_low_data_nibble_is_lar  A:C34D
zp_stack_low_data_nibble_ready   A:C350
zp_stack_low_nibble_is_larger_t  A:C303
zp_stack_low_nibble_ready        A:C306
zp_stack_ram_is_not_ok           A:C266
zp_stack_ram_is_ok               A:C365

Symbols by value:
0000 ram_block_0
0000 RAM_BANK
0000 BANKED_ROM_END_ADDR
0001 ROM_BANK
0002 INDENT_SIZE
0002 SPI_CHIP_DESELECT_AND_SLOW
0002 MARGIN
0002 TMP1
0003 SPI_CHIP_SELECT_AND_SLOW
0003 TMP2
0005 TMP4
0006 TEXT_TO_PRINT
0008 TEXT_COLOR
0009 CURSOR_X
000A CURSOR_Y
000B INDENTATION
000C BYTE_TO_PRINT
000D DECIMAL_STRING
0010 START_ADDR_HIGH
0011 END_ADDR_HIGH
0012 BANK_TESTING
0014 MEMORY_ADDR_TESTING
0016 NR_OF_WORKING_RAM_BANKS
0018 NR_OF_UNIQUE_RAM_BANKS
001A BAD_VALUE
0020 TIMING_COUNTER
0020 NR_OF_ROM_BANKS
0022 COUNTER_IS_RUNNING
0023 ESTIMATED_CPU_SPEED_PCM
0024 ESTIMATED_CPU_SPEED_VSYNC
0040 TILE_MAP_HEIGHT
0041 COLOR_NORMAL
0042 COLOR_ERROR
0043 COLOR_TITLE
0045 COLOR_OK
0047 COLOR_HEADER
0048 COLOR_WARNING
0080 TILE_MAP_WIDTH
0100 ram_block_1
0200 FIXED_RAM_START_ADDR
1000 IRQ_RAM_ADDRES
4000 ROM_TEST_CODE
9F00 FIXED_RAM_END_ADDR
9F20 VERA_ADDR_LOW
9F21 VERA_ADDR_HIGH
9F22 VERA_ADDR_BANK
9F23 VERA_DATA0
9F24 VERA_DATA1
9F25 VERA_CTRL
9F26 VERA_IEN
9F27 VERA_ISR
9F29 VERA_DC_VIDEO
9F2A VERA_DC_HSCALE
9F2B VERA_DC_VSCALE
9F2D VERA_L0_CONFIG
9F2E VERA_L0_MAPBASE
9F2F VERA_L0_TILEBASE
9F30 VERA_L0_HSCROLL_L
9F31 VERA_L0_HSCROLL_H
9F32 VERA_L0_VSCROLL_L
9F33 VERA_L0_VSCROLL_H
9F37 VERA_L1_HSCROLL_L
9F3B VERA_AUDIO_CTRL
9F3C VERA_AUDIO_RATE
9F3D VERA_AUDIO_DATA
9F3E VERA_SPI_DATA
9F3F VERA_SPI_CTRL
9F60 IO3_BASE_ADDRESS
A000 BANKED_RAM_START_ADDR
C000 reset
C000 BANKED_RAM_END_ADDR
C000 BANKED_ROM_START_ADDR
C003 wait_for_vera
C014 vera_boot_snooze
C01C vera_ready
C04B vera_tilemap_done
C09D copy_petscii_0
C0A8 copy_petscii_1
C0B3 copy_petscii_2
C0BE copy_petscii_3
C0C9 copy_petscii_4
C0D4 copy_petscii_5
C0DF copy_petscii_6
C0EA copy_petscii_7
C0F3 vera_clear_start
C104 vera_clear_fill_tile_map
C106 vera_clear_fill_tile_map_row
C116 print_title
C127 print_title_message
C130 title_smaller_than_a
C137 title_between_A_and_a
C13D title_larger_than_or_equal_to_a
C143 title_char_convert_done
C14F title_message
C172 print_fixed_ram_header
C172 done_print_title_message
C183 print_fixed_ram_message
C18C fixed_ram_smaller_than_a
C193 fixed_ram_between_A_and_a
C199 fixed_ram_larger_than_or_equal_to_a
C19F fixed_ram_char_convert_done
C1AB print_testing_zp_stack_ram
C1AB done_print_fixed_ram_message
C1BC print_testing_message
C1C5 smaller_than_a
C1CC between_A_and_a
C1D2 larger_than_or_equal_to_a
C1D8 char_convert_done
C1E4 done_print_testing_message
C1E7 testing_message
C21F test_zp_stack_ram_start
C223 check_ram_block_0_FF
C232 check_ram_block_0_00
C243 check_ram_block_1_FF
C254 check_ram_block_1_00
C263 zp_stack_done_checking_ram
C266 zp_stack_ram_is_not_ok
C2EB zp_stack_high_nibble_is_larger_than_or_equal_to_10
C2EE zp_stack_high_nibble_ready
C303 zp_stack_low_nibble_is_larger_than_or_equal_to_10
C306 zp_stack_low_nibble_ready
C333 zp_stack_high_data_nibble_is_larger_than_or_equal_to_10
C336 zp_stack_high_data_nibble_ready
C34D zp_stack_low_data_nibble_is_larger_than_or_equal_to_10
C350 zp_stack_low_data_nibble_ready
C362 zp_stack_loop_ram_not_ok
C365 zp_stack_ram_is_ok
C3AA done_with_sd_checks
C3B6 loop
C3B9 ok_message
C3BC not_ok_message
C3C3 spi_command_error
C3CF move_cursor_to_next_line
C3D8 setup_cursor
C3EC print_text_zero
C3F4 print_next_char
C3FC char_smaller_than_a
C403 char_between_A_and_a
C409 char_larger_than_or_equal_to_a
C40F char_conversion_done
C41B done_print_text
C425 print_byte_as_decimal
C450 print_hundreds
C45C print_tens
C468 print_ones
C475 mod10
C49B print_fixed_ram_address
C4F8 print_banked_address
C566 print_lower_vram_address
C5CF print_upper_vram_address
C638 print_spi_cmd_error
C679 print_byte_as_hex
C689 high_nibble_is_larger_than_or_equal_to_10
C68C high_nibble_ready
C6A4 low_nibble_is_larger_than_or_equal_to_10
C6A7 low_nibble_ready
C6B2 test_ram_block
C6B8 check_next_ram_block
C6BC check_ram_block_FF
C6CB check_ram_block_00
C6E1 ram_is_not_ok
C6E5 done_testing_ram
C6E6 fixed_ram_header_message
C6F1 testing_fixed_ram_message
C718 test_fixed_ram
C734 fixed_ram_is_ok
C746 fixed_ram_is_not_ok
C75A done_testing_fixed_ram
C75E banked_ram_header
C76A testing_banked_ram_message1
C773 testing_banked_ram_message2
C79A nr_of_working_ram_banks_message
C7C5 nr_of_unique_ram_banks_message
C7EF nr_of_ram_banks_256_message
C7F3 print_banked_ram_header
C815 test_banked_ram
C830 print_256_unique_while_testing
C83B done_printing_nr_of_banked_ram
C84A next_ram_bank_to_test
C870 banked_ram_is_ok
C88C banked_ram_is_not_ok
C8A0 done_testing_banked_ram
C8A4 determine_nr_of_ram_banks
C8B0 check_for_working_next_ram_bank
C8D5 bank_is_not_working
C8DB start_unique_ram_check
C8DD check_next_ram_bank
C8FA bank_already_counted
C8FC done_nr_of_banks
C91B print_256_working
C92A done_printing_working_banks
C94A print_unique_banks_not_ok
C951 print_unique_banks_ok
C955 print_unique_banks
C95D print_256_unique
C96C done_printing_unique_banks
C970 banked_rom_header
C97C testing_banked_rom_message
C9A8 print_banked_rom_header
C9CA test_rom_banks
C9CC copy_rom_test_code_byte
C9F2 next_rom_bank_to_test
CA0B banked_rom_is_ok
CA1D banked_rom_is_not_ok
CA31 done_testing_banked_rom
CA35 test_rom_bank
CA40 check_next_rom_block
CA44 check_rom_block
CA59 rom_is_not_ok
CA63 end_of_test_rom_bank
CA63 vera_video_header
CA71 testing_vram_message
CA95 testing_vsync_irq_message
CAB3 testing_measure_cpu_speed_using_vsync_message
CADE testing_measure_cpu_speed_using_pcm_message
CB0E mhz_message
CB12 too_high_message
CB1B too_low_message
CB23 no_buffer_fill_message
CB32 print_vera_video_header
CB54 lower_vram_not_ok_jmp
CB57 test_vram
CB6B next_vram_block_FF
CB6D next_vram_byte_FF
CB89 next_vram_block_00
CB8B next_vram_byte_00
CBB4 next_vram_block_high_FF
CBB6 next_vram_byte_high_FF
CBD4 next_vram_block_high_00
CBD6 next_vram_byte_high_00
CC0E upper_vram_not_ok
CC3A lower_vram_not_ok
CC58 done_vram_test
CC5C copy_tiles_and_map_to_low_vram
CC61 next_vram_block_copy
CC63 next_vram_byte_copy
CC72 copy_back_tiles_and_map_to_high_vram
CC77 next_vram_block_copy_back
CC79 next_vram_byte_copy_back
CC88 setup_vram_address_00000
CCB1 setup_vram_address_10000
CCDA setup_vram_address_copy
CD03 measure_cpu_speed_using_pcm
CD20 fill_pcm_audio_block_with_ff
CD22 fill_pcm_audio_byte_with_ff
CD37 wait_block_during_pcm_playback
CD39 wait_single_during_pcm_playback
CD4C fill_pcm_audio_byte
CD55 no_increment_counter_pcm
CD77 cpu_speed_done_pcm
CD79 measured_ok_cpu_speed_pcm
CD90 cpu_speed_too_high_pcm
CDA2 audio_buffer_is_not_full
CDB1 done_measuring_cpu_speed_pcm
CDB5 measure_cpu_speed_using_vsync
CDC6 copy_irq_cpu_speed_measurment_code
CDE4 waiting_to_start_counter_vsync
CDEC waiting_no_increment_vsync
CDF6 increment_counter
CDFC no_increment
CE3E cpu_speed_done_vsync
CE40 measured_ok_cpu_speed_vsync
CE46 cpu_speed_too_low_vsync
CE58 waiting_too_long_vsync
CE67 done_measuring_cpu_speed_vsync
CE6C print_cpu_speed_vsync
CE75 cpu_speeds_differ
CE77 color_cpu_speed_done
CE8A irq_cpu_speed_measurment
CE95 start_counter
CE99 end_of_interrupt
CEA0 vera_sd_header
CEA0 end_of_irq_cpu_speed_measurment
CEAB vera_sd_reset_message
CED0 vera_check_sdc_version_message
CEF4 vera_sd_initialize_message
CF0E vera_sd_no_card_detected
CF1F vera_sd_timeout_message
CF27 print_vera_sd_header
CF49 vera_initialize_sd_card
CF5D command55_timed_out
CF6F command55_success
CF78 command41_timed_out
CF8A command41_success
CFA0 command41_still_in_idle_state
CFA8 command55_not_in_idle_state
CFAD done_with_initialize_do_not_proceed
CFB7 done_with_initialize_proceed
CFBC vera_reset_sd_card
CFD2 spi_dummy_clock_loop
CFE8 command0_timed_out
CFFA command0_success
D010 command0_not_in_idle_state
D015 done_with_command0_do_not_proceed
D01F done_with_command0_proceed
D024 vera_check_sdc_version
D038 command8_timed_out
D04A command8_success
D06C command8_not_in_idle_state
D071 done_with_command8_do_not_proceed
D07B done_with_command8_proceed
D080 spi_send_command0
D09A spi_wait_command0
D0AA spi_command0_timeout
D0AC spi_send_command8
D0CA spi_wait_command8
D0DA spi_command8_timeout
D0DC spi_send_command55
D0F4 spi_wait_command55
D104 spi_command55_timeout
D106 spi_send_command41
D120 spi_wait_command41
D130 spi_command41_timeout
D132 spi_read_byte
D137 wait_spi_read_busy
D140 spi_write_byte
D143 wait_spi_write_busy
F700 petscii_0
F800 petscii_1
F900 petscii_2
FA00 petscii_3
FB00 petscii_4
FC00 petscii_5
FD00 petscii_6
FE00 petscii_7
FF00 nmi
FF04 irq
